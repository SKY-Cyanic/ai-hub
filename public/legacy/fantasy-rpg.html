<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Legends of Aetheria - 10 Classes RPG</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Noto+Sans+KR:wght@400;700;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            font-family: 'Noto Sans KR', sans-serif;
            overflow: hidden;
            user-select: none;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
        }
        
        html {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .game-font { font-family: 'Cinzel', serif; }
        
        #gameCanvas {
            display: block;
            cursor: crosshair;
        }
        
        .ui-panel {
            background: linear-gradient(135deg, rgba(20, 20, 35, 0.95), rgba(10, 10, 20, 0.98));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        /* Main Menu */
        #main-menu {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0f 100%);
            z-index: 100;
        }
        
        #main-menu h1 {
            font-size: 4rem;
            background: linear-gradient(135deg, #ffd700, #ff6b35, #ff3366);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 60px rgba(255, 100, 50, 0.5);
            margin-bottom: 0.5rem;
        }
        
        #main-menu h2 {
            font-size: 1.5rem;
            color: #888;
            margin-bottom: 2rem;
            letter-spacing: 8px;
        }
        
        .class-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            max-width: 900px;
            margin-bottom: 2rem;
        }
        
        .class-card {
            padding: 15px 10px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid rgba(255,255,255,0.1);
            background: rgba(30, 30, 50, 0.8);
            text-align: center;
            min-width: 160px;
            position: relative;
            overflow: hidden;
        }
        
        .class-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }
        
        .class-card:hover::before {
            left: 100%;
        }
        
        .class-card:hover {
            transform: translateY(-5px);
            border-color: rgba(255,255,255,0.3);
        }
        
        .class-card.selected {
            border-color: var(--class-color);
            box-shadow: 0 0 30px var(--class-glow);
            background: rgba(50, 50, 80, 0.9);
        }
        
        .class-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .class-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
        }
        
        .class-desc {
            font-size: 10px;
            color: #888;
            line-height: 1.4;
            min-height: 28px;
        }
        
        .class-stats {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 8px;
            font-size: 9px;
        }
        
        .class-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2px 5px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
        }
        
        .class-stat-value {
            font-weight: bold;
            color: #fff;
        }
        
        .class-stat-label {
            color: #666;
            font-size: 8px;
        }
        
        .class-passive {
            font-size: 9px;
            color: #aaa;
            margin-top: 8px;
            padding: 6px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            border-left: 2px solid var(--class-color);
        }
        
        .class-type-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 8px;
            padding: 2px 6px;
            border-radius: 10px;
            background: rgba(0,0,0,0.5);
            color: #888;
        }
        
        #start-btn {
            padding: 18px 60px;
            font-size: 1.3rem;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.4);
        }
        
        #start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 50px rgba(102, 126, 234, 0.6);
        }
        
        /* Game UI */
        #game-ui {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: none;
        }
        
        #game-ui > * {
            pointer-events: auto;
        }
        
        /* Player Stats Panel */
        #stats-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px;
            min-width: 280px;
        }
        
        .stat-bar {
            height: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 8px;
            position: relative;
        }
        
        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s;
            border-radius: 10px;
        }
        
        .stat-bar-text {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        
        /* Skills Bar */
        #skills-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            padding: 15px;
        }
        
        .skill-slot {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid rgba(255,255,255,0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(30, 30, 50, 0.9);
        }
        
        .skill-slot:hover:not(.locked):not(.on-cooldown) {
            transform: translateY(-5px);
            border-color: rgba(255,255,255,0.5);
        }
        
        .skill-slot.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .skill-slot .skill-icon {
            font-size: 24px;
        }
        
        .skill-slot .skill-key {
            position: absolute;
            top: 2px;
            left: 5px;
            font-size: 10px;
            color: #ffd700;
            font-weight: bold;
        }
        
        .skill-slot .skill-level {
            position: absolute;
            bottom: 2px;
            right: 5px;
            font-size: 9px;
            color: #aaa;
        }
        
        .skill-slot .cooldown-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: white;
        }
        
        /* Minimap */
        #minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px;
        }
        
        #minimap {
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.1);
        }
        
        /* Info Panel */
        #info-panel {
            position: absolute;
            top: 200px;
            left: 20px;
            padding: 12px;
            font-size: 12px;
            min-width: 150px;
        }
        
        #info-panel div {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        /* Boss HP */
        #boss-hp-container {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            max-width: 80vw;
            display: none;
        }
        
        #boss-hp-bar {
            height: 25px;
            background: rgba(0,0,0,0.7);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid #dc2626;
        }
        
        #boss-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc2626, #f97316, #fbbf24);
            transition: width 0.3s;
        }
        
        /* Level Up Modal */
        #levelup-modal {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        
        #levelup-modal.show {
            display: flex;
        }
        
        .upgrade-cards {
            display: flex;
            gap: 20px;
        }
        
        .upgrade-card {
            width: 200px;
            padding: 25px;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid rgba(255,255,255,0.1);
            background: rgba(30, 30, 50, 0.95);
            text-align: center;
        }
        
        .upgrade-card:hover {
            transform: translateY(-10px) scale(1.05);
            border-color: var(--card-color);
            box-shadow: 0 20px 60px var(--card-glow);
        }
        
        /* Game Over */
        #gameover-modal {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 100;
        }
        
        #gameover-modal.show {
            display: flex;
        }
        
        /* Floating Damage */
        .floating-text {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            animation: floatUp 1s ease-out forwards;
            text-shadow: 2px 2px 4px black;
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.3); }
        }
        
        /* Buff Display */
        #buff-container {
            position: absolute;
            top: 160px;
            right: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-width: 200px;
            justify-content: flex-end;
        }
        
        .buff-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            position: relative;
        }
        
        .buff-icon .buff-time {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: 9px;
            background: rgba(0,0,0,0.8);
            padding: 1px 3px;
            border-radius: 3px;
        }
        
        /* Combo Display */
        #combo-display {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            text-align: right;
            display: none;
        }
        
        #combo-display.show {
            display: block;
        }
        
        #combo-count {
            font-size: 4rem;
            font-weight: 900;
            color: #fbbf24;
            text-shadow: 0 0 30px rgba(251, 191, 36, 0.8);
        }
        
        /* Stage Info */
        #stage-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
        }
        
        #stage-name {
            font-size: 1.2rem;
            color: #fbbf24;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }
        
        #time-weather {
            font-size: 0.9rem;
            color: #888;
            margin-top: 5px;
        }
        
        /* Boss Raid Gimmick Warning */
        #gimmick-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 60;
            pointer-events: none;
        }
        
        #gimmick-warning.show {
            display: block;
            animation: pulseWarning 0.5s ease-in-out infinite;
        }
        
        @keyframes pulseWarning {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
        
        #gimmick-warning .warning-text {
            font-size: 2rem;
            color: #ef4444;
            text-shadow: 0 0 30px rgba(239, 68, 68, 0.8);
            font-weight: bold;
        }
        
        #gimmick-warning .warning-desc {
            font-size: 1rem;
            color: #fbbf24;
            margin-top: 10px;
        }
        
        /* Skill Tree Modal */
        #skilltree-modal {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 80;
        }
        
        #skilltree-modal.show {
            display: flex;
        }
        
        .skill-tree-container {
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            padding: 30px;
        }
        
        .skill-tree-title {
            font-size: 2rem;
            color: #fbbf24;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .skill-tree-points {
            text-align: center;
            color: #22d3ee;
            margin-bottom: 20px;
        }
        
        .skill-tree-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }
        
        .skill-tree-node {
            padding: 15px;
            border-radius: 12px;
            background: rgba(30,30,50,0.9);
            border: 2px solid rgba(255,255,255,0.1);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .skill-tree-node:hover:not(.locked):not(.maxed) {
            border-color: #fbbf24;
            transform: translateY(-3px);
        }
        
        .skill-tree-node.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .skill-tree-node.maxed {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.2);
        }
        
        .skill-tree-node .node-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }
        
        .skill-tree-node .node-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .skill-tree-node .node-level {
            font-size: 0.8rem;
            color: #888;
        }
        
        .skill-tree-node .node-desc {
            font-size: 0.75rem;
            color: #aaa;
            margin-top: 8px;
        }
        
        /* Weather overlay */
        #weather-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 5;
        }
        
        .rain-drop {
            position: absolute;
            width: 2px;
            height: 15px;
            background: linear-gradient(to bottom, transparent, rgba(100, 180, 255, 0.6));
            animation: rainFall 0.5s linear infinite;
        }
        
        @keyframes rainFall {
            0% { transform: translateY(-20px); }
            100% { transform: translateY(100vh); }
        }
        
        .snow-flake {
            position: absolute;
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            opacity: 0.8;
            animation: snowFall 3s linear infinite;
        }
        
        @keyframes snowFall {
            0% { transform: translateY(-20px) rotate(0deg); }
            100% { transform: translateY(100vh) rotate(360deg); }
        }
        
        /* Stage Transition */
        #stage-transition {
            position: absolute;
            inset: 0;
            background: #000;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 90;
        }
        
        #stage-transition.show {
            display: flex;
            animation: fadeInOut 2s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* Passive Display */
        #passive-display {
            position: absolute;
            bottom: 100px;
            left: 20px;
            padding: 10px 15px;
            font-size: 12px;
        }
        
        /* Mobile Controls */
        #mobile-controls {
            display: none;
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 40;
        }
        
        #mobile-controls.show {
            display: block;
        }
        
        #mobile-controls > * {
            pointer-events: auto;
        }
        
        /* Virtual Joystick */
        #joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 140px;
            height: 140px;
        }
        
        #joystick-base {
            position: absolute;
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }
        
        #joystick-stick {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255,255,255,0.8), rgba(255,255,255,0.4));
            border: 2px solid rgba(255,255,255,0.6);
            left: 40px;
            top: 40px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: none;
        }
        
        /* Attack Button */
        #attack-btn {
            position: absolute;
            bottom: 50px;
            right: 50px;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border: 3px solid rgba(255,255,255,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            box-shadow: 0 6px 25px rgba(239, 68, 68, 0.5);
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #attack-btn:active {
            transform: scale(0.9);
            box-shadow: 0 3px 15px rgba(239, 68, 68, 0.5);
        }
        
        /* Dash Button */
        #dash-btn {
            position: absolute;
            bottom: 160px;
            right: 60px;
            width: 65px;
            height: 65px;
            border-radius: 50%;
            background: linear-gradient(135deg, #22d3ee, #0891b2);
            border: 3px solid rgba(255,255,255,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 4px 20px rgba(34, 211, 238, 0.5);
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #dash-btn:active {
            transform: scale(0.9);
        }
        
        /* Mobile Skill Buttons */
        #mobile-skills {
            position: absolute;
            bottom: 50px;
            right: 160px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .mobile-skill-row {
            display: flex;
            gap: 10px;
        }
        
        .mobile-skill-btn {
            width: 55px;
            height: 55px;
            border-radius: 12px;
            background: rgba(30, 30, 50, 0.9);
            border: 2px solid rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            position: relative;
        }
        
        .mobile-skill-btn.locked {
            opacity: 0.4;
        }
        
        .mobile-skill-btn.on-cooldown {
            opacity: 0.6;
        }
        
        .mobile-skill-btn .mobile-skill-cd {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: white;
        }
        
        /* Mobile UI Adjustments */
        @media (max-width: 768px) {
            #main-menu h1 {
                font-size: 2rem;
            }
            
            #main-menu h2 {
                font-size: 1rem;
                letter-spacing: 4px;
            }
            
            .class-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
                max-width: 95vw;
                padding: 0 10px;
            }
            
            .class-card {
                padding: 10px 8px;
                min-width: auto;
            }
            
            .class-icon {
                width: 45px;
                height: 45px;
                font-size: 22px;
            }
            
            .class-name {
                font-size: 12px;
            }
            
            .class-desc {
                font-size: 9px;
                min-height: 20px;
            }
            
            .class-stats {
                gap: 4px;
            }
            
            .class-passive {
                font-size: 8px;
                padding: 4px;
            }
            
            #start-btn {
                padding: 14px 40px;
                font-size: 1rem;
            }
            
            #stats-panel {
                top: 10px;
                left: 10px;
                padding: 10px;
                min-width: 200px;
                transform: scale(0.85);
                transform-origin: top left;
            }
            
            #info-panel {
                display: none;
            }
            
            #minimap-container {
                top: 10px;
                right: 10px;
                transform: scale(0.7);
                transform-origin: top right;
            }
            
            #passive-display {
                display: none;
            }
            
            #volume-panel {
                display: none;
            }
            
            #skills-bar {
                display: none;
            }
            
            #boss-hp-container {
                top: 100px;
                width: 80vw;
            }
            
            #combo-display {
                top: 30%;
                right: 10px;
            }
            
            #combo-count {
                font-size: 2.5rem;
            }
            
            .upgrade-cards {
                flex-direction: column;
                gap: 12px;
            }
            
            .upgrade-card {
                width: 80vw;
                padding: 15px;
            }
            
            #levelup-modal > div:first-child .game-font {
                font-size: 2rem !important;
            }
        }
        
        @media (max-width: 480px) {
            .class-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            #joystick-container {
                width: 120px;
                height: 120px;
                bottom: 20px;
                left: 20px;
            }
            
            #joystick-base {
                width: 120px;
                height: 120px;
            }
            
            #joystick-stick {
                width: 50px;
                height: 50px;
                left: 35px;
                top: 35px;
            }
            
            #attack-btn {
                width: 75px;
                height: 75px;
                bottom: 30px;
                right: 30px;
                font-size: 28px;
            }
            
            #dash-btn {
                width: 55px;
                height: 55px;
                bottom: 120px;
                right: 40px;
                font-size: 20px;
            }
            
            #mobile-skills {
                right: 120px;
                bottom: 30px;
            }
            
            .mobile-skill-btn {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Main Menu -->
    <div id="main-menu">
        <h1 class="game-font">LEGENDS OF AETHERIA</h1>
        <h2>10 CLASSES EDITION</h2>
        
        <div class="class-grid" id="class-grid">
            <!-- Classes will be injected -->
        </div>
        
        <button id="start-btn" class="game-font">⚔️ 모험 시작</button>
        
        <div id="control-hints" style="margin-top: 20px; color: #666; font-size: 12px;">
            <span class="desktop-hint">WASD 이동 | 마우스 공격 | 1-6 스킬 | SHIFT 대시 | ESC 일시정지</span>
            <span class="mobile-hint" style="display: none;">🕹️ 조이스틱 이동 | ⚔️ 공격 | 💨 대시 | 스킬 버튼으로 스킬 사용</span>
        </div>
    </div>
    
    <!-- Game UI -->
    <div id="game-ui">
        <!-- Player Stats -->
        <div id="stats-panel" class="ui-panel">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <div id="player-icon" style="width: 45px; height: 45px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 22px;"></div>
                <div>
                    <div id="player-class" style="font-weight: bold; font-size: 14px;"></div>
                    <div style="font-size: 11px; color: #888;">LV.<span id="player-level">1</span> | Wave <span id="wave-num">1</span></div>
                </div>
            </div>
            
            <div class="stat-bar">
                <div id="hp-bar" class="stat-bar-fill" style="background: linear-gradient(90deg, #dc2626, #ef4444); width: 100%;"></div>
                <div class="stat-bar-text">HP: <span id="hp-text">100/100</span></div>
            </div>
            
            <div class="stat-bar">
                <div id="mp-bar" class="stat-bar-fill" style="background: linear-gradient(90deg, #2563eb, #3b82f6); width: 100%;"></div>
                <div class="stat-bar-text">MP: <span id="mp-text">100/100</span></div>
            </div>
            
            <div class="stat-bar" style="height: 12px;">
                <div id="exp-bar" class="stat-bar-fill" style="background: linear-gradient(90deg, #9333ea, #a855f7); width: 0%;"></div>
                <div class="stat-bar-text" style="font-size: 9px;">EXP: <span id="exp-text">0/100</span></div>
            </div>
            
            <div class="stat-bar" style="height: 8px; margin-top: 5px;">
                <div id="dash-bar" class="stat-bar-fill" style="background: #22d3ee; width: 100%;"></div>
            </div>
        </div>
        
        <!-- Info Panel -->
        <div id="info-panel" class="ui-panel">
            <div><span style="color: #888;">ATK</span><span id="stat-atk" style="color: #ef4444;">10</span></div>
            <div><span style="color: #888;">DEF</span><span id="stat-def" style="color: #3b82f6;">5</span></div>
            <div><span style="color: #888;">SPD</span><span id="stat-spd" style="color: #22c55e;">5.0</span></div>
            <div><span style="color: #888;">CRIT</span><span id="stat-crit" style="color: #fbbf24;">5%</span></div>
            <div><span style="color: #888;">KILLS</span><span id="stat-kills" style="color: #fff;">0</span></div>
            <div><span style="color: #888;">GOLD</span><span id="stat-gold" style="color: #fbbf24;">0</span></div>
            <div><span style="color: #888;">TIME</span><span id="stat-time" style="color: #fff;">00:00</span></div>
            <div><span style="color: #888;">STAGE</span><span id="stat-stage" style="color: #fbbf24;">1</span></div>
            <div><span style="color: #888;">KILLS</span><span id="stage-progress" style="color: #22c55e;">0/30</span></div>
            <div><span style="color: #888;">SP</span><span id="skill-points" style="color: #22d3ee;">0</span></div>
        </div>
        
        <!-- Skill Tree Button -->
        <div id="skilltree-btn" class="ui-panel" style="position: absolute; top: 350px; left: 20px; padding: 10px 15px; cursor: pointer; font-size: 12px;">
            🌳 스킬트리 (T)
        </div>
        
        <!-- Volume Control -->
        <div id="volume-panel" class="ui-panel" style="position: absolute; bottom: 100px; right: 20px; padding: 12px; min-width: 120px;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                <span style="font-size: 16px;">🔊</span>
                <input type="range" id="volume-slider" min="0" max="100" value="30" style="width: 80px; cursor: pointer;">
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 16px;">🎵</span>
                <button id="bgm-toggle" style="background: rgba(100,100,150,0.5); border: 1px solid rgba(255,255,255,0.2); color: #fff; padding: 4px 10px; border-radius: 5px; cursor: pointer; font-size: 11px;">BGM OFF</button>
            </div>
        </div>
        
        <!-- Passive Display -->
        <div id="passive-display" class="ui-panel">
            <div style="color: #fbbf24; font-weight: bold; margin-bottom: 5px;">⭐ 패시브</div>
            <div id="passive-text" style="color: #aaa;"></div>
        </div>
        
        <!-- Minimap -->
        <div id="minimap-container" class="ui-panel">
            <canvas id="minimap" width="150" height="150"></canvas>
        </div>
        
        <!-- Buff Container -->
        <div id="buff-container"></div>
        
        <!-- Combo Display -->
        <div id="combo-display">
            <div id="combo-count" class="game-font">0</div>
            <div style="color: #f97316; font-size: 14px;">COMBO</div>
        </div>
        
        <!-- Stage Info -->
        <div id="stage-info">
            <div id="stage-name" class="game-font">🌲 초원 스테이지</div>
            <div id="time-weather">☀️ 낮 | 맑음</div>
        </div>
        
        <!-- Gimmick Warning -->
        <div id="gimmick-warning">
            <div class="warning-text">⚠️ 경고!</div>
            <div class="warning-desc">보스 기믹 발동!</div>
        </div>
        
        <!-- Weather Overlay -->
        <div id="weather-overlay"></div>
        
        <!-- Stage Transition -->
        <div id="stage-transition">
            <div class="game-font" style="font-size: 3rem; color: #fbbf24;">스테이지 이동 중...</div>
            <div id="next-stage-name" style="color: #888; margin-top: 20px;"></div>
        </div>
        
        <!-- Boss HP -->
        <div id="boss-hp-container" class="ui-panel" style="padding: 10px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span id="boss-name" style="color: #ef4444; font-weight: bold;">BOSS</span>
                <span id="boss-hp-text" style="color: #888; font-size: 12px;">100%</span>
            </div>
            <div id="boss-hp-bar">
                <div id="boss-hp-fill" style="width: 100%;"></div>
            </div>
        </div>
        
        <!-- Skills Bar -->
        <div id="skills-bar" class="ui-panel">
            <!-- Skills will be injected -->
        </div>
    </div>
    
    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <!-- Virtual Joystick -->
        <div id="joystick-container">
            <div id="joystick-base"></div>
            <div id="joystick-stick"></div>
        </div>
        
        <!-- Attack Button -->
        <div id="attack-btn">⚔️</div>
        
        <!-- Dash Button -->
        <div id="dash-btn">💨</div>
        
        <!-- Mobile Skills -->
        <div id="mobile-skills">
            <div class="mobile-skill-row">
                <div class="mobile-skill-btn" data-skill="0"></div>
                <div class="mobile-skill-btn" data-skill="1"></div>
                <div class="mobile-skill-btn" data-skill="2"></div>
            </div>
            <div class="mobile-skill-row">
                <div class="mobile-skill-btn" data-skill="3"></div>
                <div class="mobile-skill-btn" data-skill="4"></div>
                <div class="mobile-skill-btn" data-skill="5"></div>
            </div>
        </div>
    </div>
    
    <!-- Level Up Modal -->
    <div id="levelup-modal">
        <div style="text-align: center; margin-bottom: 30px;">
            <div class="game-font" style="font-size: 3rem; color: #fbbf24; text-shadow: 0 0 30px rgba(251, 191, 36, 0.8);">LEVEL UP!</div>
            <div style="color: #888;">능력을 선택하세요</div>
        </div>
        <div class="upgrade-cards" id="upgrade-cards"></div>
    </div>
    
    <!-- Skill Tree Modal -->
    <div id="skilltree-modal">
        <div class="skill-tree-container ui-panel">
            <div class="skill-tree-title game-font">🌳 스킬 트리</div>
            <div class="skill-tree-points">스킬 포인트: <span id="st-points">0</span></div>
            <button onclick="document.getElementById('skilltree-modal').classList.remove('show'); game.paused = false;" 
                    style="position: absolute; top: 20px; right: 20px; background: #ef4444; border: none; color: white; padding: 8px 15px; border-radius: 5px; cursor: pointer;">닫기</button>
            
            <div style="margin-bottom: 15px; color: #888; text-align: center;">노드 클릭으로 스킬 포인트 사용</div>
            
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;">
                <div>
                    <h3 style="color: #ef4444; text-align: center; margin-bottom: 10px;">⚔️ 공격</h3>
                    <div id="st-offense" class="skill-tree-grid" style="display: flex; flex-direction: column; gap: 10px;"></div>
                </div>
                <div>
                    <h3 style="color: #22c55e; text-align: center; margin-bottom: 10px;">🛡️ 방어</h3>
                    <div id="st-defense" class="skill-tree-grid" style="display: flex; flex-direction: column; gap: 10px;"></div>
                </div>
                <div>
                    <h3 style="color: #3b82f6; text-align: center; margin-bottom: 10px;">✨ 유틸</h3>
                    <div id="st-utility" class="skill-tree-grid" style="display: flex; flex-direction: column; gap: 10px;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="gameover-modal">
        <div class="game-font" style="font-size: 4rem; color: #ef4444; margin-bottom: 30px; text-shadow: 0 0 50px rgba(239, 68, 68, 0.8);">GAME OVER</div>
        <div class="ui-panel" style="padding: 30px; text-align: center;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 25px;">
                <div>레벨: <span id="go-level" style="color: #fbbf24;">1</span></div>
                <div>웨이브: <span id="go-wave" style="color: #a855f7;">1</span></div>
                <div>처치: <span id="go-kills" style="color: #ef4444;">0</span></div>
                <div>골드: <span id="go-gold" style="color: #fbbf24;">0</span></div>
                <div>콤보: <span id="go-combo" style="color: #f97316;">0</span></div>
                <div>시간: <span id="go-time" style="color: #22d3ee;">00:00</span></div>
            </div>
            <button onclick="location.reload()" style="padding: 15px 50px; font-size: 1.2rem; background: linear-gradient(135deg, #667eea, #764ba2); border: none; border-radius: 30px; color: white; cursor: pointer;">다시 도전</button>
        </div>
    </div>

    <script>
    // ============= GAME SETUP =============
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const minimap = document.getElementById('minimap');
    const minimapCtx = minimap.getContext('2d');

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Constants
    const WORLD_W = 4000, WORLD_H = 4000;
    const rand = (a, b) => Math.random() * (b - a) + a;
    const randInt = (a, b) => Math.floor(rand(a, b + 1));
    const dist = (a, b) => Math.hypot(b.x - a.x, b.y - a.y);
    const angle = (a, b) => Math.atan2(b.y - a.y, b.x - a.x);
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const lerp = (a, b, t) => a + (b - a) * t;

    // ============= 10 CLASSES DEFINITION =============
    const CLASSES = {
        warrior: {
            name: '전사', icon: '⚔️', color: '#3b82f6', 
            desc: '강력한 근접 공격과 높은 생존력을 가진 전투의 최전선',
            hp: 150, mp: 60, atk: 18, def: 12, spd: 4.5, critRate: 0.08,
            attackType: 'melee', attackRange: 65,
            passive: { name: '강철 의지', desc: 'HP가 20% 이하일 때 방어력이 2배로 증가하여 위기 상황에서 더욱 강해집니다', effect: 'ironWill' },
            skills: [
                { name: '강타', icon: '💥', cost: 15, cooldown: 3, unlockLv: 1, desc: '무기에 힘을 실어 전방의 적에게 공격력의 200% 피해를 입힙니다' },
                { name: '방패 올리기', icon: '🛡️', cost: 20, cooldown: 8, unlockLv: 2, desc: '3초간 모든 피해를 무효화하는 완벽한 방어 태세를 취합니다' },
                { name: '회오리', icon: '🌀', cost: 30, cooldown: 6, unlockLv: 4, desc: '360도 회전하며 주변 모든 적에게 공격력의 150% 피해를 입힙니다' },
                { name: '전사의 함성', icon: '📢', cost: 25, cooldown: 12, unlockLv: 6, desc: '5초간 공격력이 50% 증가하는 전투 함성을 지릅니다' },
                { name: '지진', icon: '🌋', cost: 50, cooldown: 15, unlockLv: 8, desc: '땅을 강타하여 반경 200 내 모든 적에게 공격력의 300% 피해를 입힙니다' },
                { name: '불멸의 의지', icon: '👊', cost: 80, cooldown: 30, unlockLv: 10, desc: '5초간 무적 상태가 되며 공격력이 2배로 증가합니다. 궁극기' }
            ]
        },
        mage: {
            name: '마법사', icon: '🔮', color: '#a855f7',
            desc: '원소의 힘을 다루어 강력한 광역 마법을 시전하는 마스터',
            hp: 80, mp: 180, atk: 25, def: 5, spd: 4, critRate: 0.12,
            attackType: 'range', attackRange: 300,
            passive: { name: '마나 친화', desc: 'MP 자연 재생량이 300% 증가하여 지속적인 마법 시전이 가능합니다', effect: 'manaAffinity' },
            skills: [
                { name: '파이어볼', icon: '🔥', cost: 20, cooldown: 2, unlockLv: 1, desc: '폭발하는 화염구를 발사하여 주변 적들에게 공격력의 200% 피해를 입힙니다' },
                { name: '아이스 샤드', icon: '❄️', cost: 25, cooldown: 4, unlockLv: 2, desc: '얼음 파편을 발사하여 적을 2초간 빙결시키고 공격력의 150% 피해를 입힙니다' },
                { name: '번개', icon: '⚡', cost: 35, cooldown: 5, unlockLv: 4, desc: '최대 3명의 적에게 연쇄되는 번개를 발사하여 각각 공격력의 150% 피해를 입힙니다' },
                { name: '텔레포트', icon: '✨', cost: 30, cooldown: 6, unlockLv: 6, desc: '마우스 위치로 순간이동하여 위험한 상황을 회피합니다' },
                { name: '메테오', icon: '☄️', cost: 60, cooldown: 12, unlockLv: 8, desc: '0.5초 후 지정 위치에 운석을 떨어뜨려 반경 120 내 공격력의 400% 피해를 입힙니다' },
                { name: '아마겟돈', icon: '💀', cost: 100, cooldown: 25, unlockLv: 10, desc: '10개의 운석을 연속으로 떨어뜨리는 최강의 광역 마법. 궁극기' }
            ]
        },
        ranger: {
            name: '궁수', icon: '🏹', color: '#22c55e',
            desc: '빠른 공격 속도와 높은 치명타로 먼 거리에서 적을 제압',
            hp: 100, mp: 100, atk: 20, def: 7, spd: 5.5, critRate: 0.18,
            attackType: 'range', attackRange: 350,
            passive: { name: '명사수', desc: '치명타 발생 시 추가 피해량이 50% 증가하여 치명타 피해가 250%가 됩니다', effect: 'sharpshooter' },
            skills: [
                { name: '멀티샷', icon: '🎯', cost: 20, cooldown: 3, unlockLv: 1, desc: '부채꼴 모양으로 5발의 화살을 동시에 발사합니다' },
                { name: '독화살', icon: '☠️', cost: 25, cooldown: 5, unlockLv: 2, desc: '맞은 적에게 3초간 매 0.5초마다 공격력의 20% 피해를 입히는 독을 바릅니다' },
                { name: '회피 사격', icon: '💨', cost: 30, cooldown: 6, unlockLv: 4, desc: '뒤로 80픽셀 점프하면서 전방으로 3발의 화살을 연속 발사합니다' },
                { name: '덫', icon: '🪤', cost: 25, cooldown: 8, unlockLv: 6, desc: '현재 위치에 10초간 지속되는 덫을 설치, 밟은 적의 이동속도가 70% 감소합니다' },
                { name: '화살 비', icon: '🌧️', cost: 50, cooldown: 10, unlockLv: 8, desc: '지정 위치에 15발의 화살을 비처럼 쏟아붓습니다' },
                { name: '저격', icon: '🎪', cost: 80, cooldown: 20, unlockLv: 10, desc: '정밀 조준하여 단일 대상에게 공격력의 500% 치명타 피해를 입힙니다. 궁극기' }
            ]
        },
        assassin: {
            name: '암살자', icon: '🗡️', color: '#6366f1',
            desc: '그림자 속에서 적의 급소를 노리는 치명적인 암살 전문가',
            hp: 90, mp: 90, atk: 22, def: 6, spd: 6, critRate: 0.25,
            attackType: 'melee', attackRange: 55,
            passive: { name: '암습', desc: '적의 후방에서 공격 시 피해량이 2배로 증가합니다', effect: 'backstab' },
            skills: [
                { name: '그림자 베기', icon: '🌑', cost: 15, cooldown: 2, unlockLv: 1, desc: '빠르게 2번 베어 각각 공격력의 120% 피해를 입힙니다' },
                { name: '은신', icon: '👤', cost: 30, cooldown: 8, unlockLv: 2, desc: '3초간 투명해져 적에게 발각되지 않습니다. 공격하면 해제됩니다' },
                { name: '독 칼날', icon: '💚', cost: 20, cooldown: 4, unlockLv: 4, desc: '5초간 기본 공격에 독을 묻혀 추가 지속 피해를 입힙니다' },
                { name: '그림자 이동', icon: '🌫️', cost: 25, cooldown: 5, unlockLv: 6, desc: '가장 가까운 적의 뒤로 순간이동합니다' },
                { name: '암살', icon: '💀', cost: 50, cooldown: 12, unlockLv: 8, desc: '급소를 정확히 찔러 공격력의 400% 치명타 피해를 입힙니다' },
                { name: '죽음의 춤', icon: '💃', cost: 80, cooldown: 20, unlockLv: 10, desc: '0.75초간 5번 연속 공격하며 각각 공격력의 150% 피해를 입힙니다. 궁극기' }
            ]
        },
        paladin: {
            name: '성기사', icon: '🛡️', color: '#fbbf24',
            desc: '신성한 힘으로 아군을 보호하고 언데드를 심판하는 수호자',
            hp: 180, mp: 100, atk: 15, def: 15, spd: 4, critRate: 0.05,
            attackType: 'melee', attackRange: 60,
            passive: { name: '신의 축복', desc: '전투 중 자동으로 매 초마다 최대 HP의 1%씩 회복됩니다', effect: 'divineBlessing' },
            skills: [
                { name: '신성한 일격', icon: '✝️', cost: 20, cooldown: 3, unlockLv: 1, desc: '신성한 힘을 담아 공격력의 200% 피해. 언데드에게는 400% 피해를 입힙니다' },
                { name: '치유의 빛', icon: '💛', cost: 35, cooldown: 8, unlockLv: 2, desc: '신성한 빛으로 자신의 HP를 최대치의 30% 회복합니다' },
                { name: '심판', icon: '⚖️', cost: 30, cooldown: 6, unlockLv: 4, desc: '반경 150 내 모든 적을 2초간 기절시키고 공격력의 100% 피해를 입힙니다' },
                { name: '신성 보호막', icon: '🔰', cost: 40, cooldown: 10, unlockLv: 6, desc: '5초간 최대 HP의 50%를 흡수하는 보호막을 생성합니다' },
                { name: '천벌', icon: '🌟', cost: 60, cooldown: 15, unlockLv: 8, desc: '0.4초 후 지정 위치에 신성한 빛을 내려 반경 100 내 공격력의 300% 피해를 입힙니다' },
                { name: '대천사 소환', icon: '👼', cost: 100, cooldown: 30, unlockLv: 10, desc: '10초간 전투를 돕는 천사를 소환합니다. 궁극기' }
            ]
        },
        necromancer: {
            name: '강령술사', icon: '💀', color: '#84cc16',
            desc: '죽은 자를 일으키고 어둠의 마법으로 적을 저주하는 사령술사',
            hp: 85, mp: 160, atk: 18, def: 6, spd: 4, critRate: 0.10,
            attackType: 'range', attackRange: 280,
            passive: { name: '영혼 수확', desc: '적을 처치할 때마다 최대 HP의 5%를 회복하여 지속적인 생존이 가능합니다', effect: 'soulHarvest' },
            skills: [
                { name: '저주', icon: '🦴', cost: 15, cooldown: 3, unlockLv: 1, desc: '적에게 저주를 걸어 5초간 매 초마다 5의 고정 피해를 입힙니다' },
                { name: '해골 소환', icon: '💀', cost: 30, cooldown: 8, unlockLv: 2, desc: '15초간 전투를 돕는 해골 병사 1기를 소환합니다' },
                { name: '생명력 흡수', icon: '🩸', cost: 25, cooldown: 5, unlockLv: 4, desc: '반경 150 내 적에게 공격력의 150% 피해를 주고 그 50%를 HP로 흡수합니다' },
                { name: '공포', icon: '👻', cost: 35, cooldown: 10, unlockLv: 6, desc: '반경 200 내 모든 적을 3초간 공포에 떨게하여 도망치게 합니다' },
                { name: '역병', icon: '☣️', cost: 50, cooldown: 12, unlockLv: 8, desc: '반경 250 내 모든 적에게 5초간 매 초마다 공격력의 20% 독 피해를 입힙니다' },
                { name: '죽음의 군대', icon: '⚰️', cost: 90, cooldown: 25, unlockLv: 10, desc: '5기의 해골 병사를 동시에 소환합니다. 궁극기' }
            ]
        },
        berserker: {
            name: '버서커', icon: '😤', color: '#dc2626',
            desc: '피가 끓을수록 강해지는 광전사. HP를 희생해 폭발적인 피해를 줍니다',
            hp: 200, mp: 40, atk: 28, def: 5, spd: 5, critRate: 0.15,
            attackType: 'melee', attackRange: 70,
            passive: { name: '광기', desc: 'HP가 낮아질수록 공격력이 최대 150%까지 증가합니다 (HP 1%당 1.5% 증가)', effect: 'rage' },
            skills: [
                { name: '분노의 일격', icon: '💢', cost: 10, cooldown: 2, unlockLv: 1, desc: '분노를 담아 공격력의 150% 피해를 입힙니다' },
                { name: '포효', icon: '🗣️', cost: 15, cooldown: 6, unlockLv: 2, desc: '반경 200 내 모든 적을 2초간 공포에 떨게 합니다' },
                { name: '피의 칼날', icon: '🩸', cost: 0, cooldown: 4, unlockLv: 4, desc: 'HP의 10%를 소모하여 공격력의 300% 피해를 입힙니다' },
                { name: '광폭화', icon: '😈', cost: 20, cooldown: 15, unlockLv: 6, desc: '5초간 공격 속도가 2배로 증가합니다' },
                { name: '처형', icon: '🪓', cost: 30, cooldown: 10, unlockLv: 8, desc: 'HP가 30% 이하인 적을 즉시 처형합니다' },
                { name: '지옥불', icon: '🔥', cost: 50, cooldown: 20, unlockLv: 10, desc: 'HP의 30%를 소모하고 반경 250 내 공격력의 500% 피해를 입힙니다. 궁극기' }
            ]
        },
        elementalist: {
            name: '정령술사', icon: '🌊', color: '#06b6d4',
            desc: '물, 불, 바람, 대지 4원소를 자유자재로 다루는 원소 마스터',
            hp: 90, mp: 150, atk: 22, def: 6, spd: 4.5, critRate: 0.10,
            attackType: 'range', attackRange: 280,
            passive: { name: '원소 친화', desc: '모든 원소 스킬의 피해량이 25% 증가합니다', effect: 'elementalMastery' },
            skills: [
                { name: '워터볼', icon: '💧', cost: 15, cooldown: 2, unlockLv: 1, desc: '물의 구체를 발사하여 공격력의 120% 피해와 함께 적의 이동속도를 50% 감소시킵니다' },
                { name: '화염 폭발', icon: '🔥', cost: 25, cooldown: 4, unlockLv: 2, desc: '지정 위치에 화염 폭발을 일으켜 반경 80 내 공격력의 200% 피해를 입힙니다' },
                { name: '바람 칼날', icon: '🌬️', cost: 20, cooldown: 3, unlockLv: 4, desc: '적을 관통하는 바람 칼날을 발사하여 최대 5명에게 공격력의 150% 피해를 입힙니다' },
                { name: '대지 진동', icon: '🌍', cost: 35, cooldown: 8, unlockLv: 6, desc: '땅을 흔들어 반경 150 내 적에게 공격력의 150% 피해와 2초 기절 효과를 줍니다' },
                { name: '폭풍 소환', icon: '🌪️', cost: 50, cooldown: 12, unlockLv: 8, desc: '5초간 지속되는 폭풍을 소환하여 반경 120 내 적에게 매 0.5초마다 피해를 입힙니다' },
                { name: '원소 융합', icon: '🌈', cost: 80, cooldown: 20, unlockLv: 10, desc: '4원소를 결합하여 반경 200 내 공격력의 500% 피해 + 빙결 + 기절 효과. 궁극기' }
            ]
        },
        priest: {
            name: '사제', icon: '⛪', color: '#f472b6',
            desc: '신성한 힘으로 치유하고 아군을 보호하는 치유 전문가',
            hp: 100, mp: 200, atk: 12, def: 8, spd: 4, critRate: 0.05,
            attackType: 'range', attackRange: 250,
            passive: { name: '신성력', desc: '모든 치유량이 50% 증가하여 더욱 효과적인 회복이 가능합니다', effect: 'holyPower' },
            skills: [
                { name: '신성 화살', icon: '🏹', cost: 10, cooldown: 2, unlockLv: 1, desc: '신성한 힘을 담은 화살을 발사하여 공격력의 120% 피해를 입힙니다' },
                { name: '치유', icon: '💖', cost: 30, cooldown: 5, unlockLv: 2, desc: '자신의 HP를 최대치의 40% (패시브 적용 시 60%) 회복합니다' },
                { name: '정화', icon: '✨', cost: 25, cooldown: 8, unlockLv: 4, desc: '자신에게 걸린 모든 디버프(독, 저주, 감속 등)를 제거합니다' },
                { name: '보호막', icon: '🔮', cost: 40, cooldown: 10, unlockLv: 6, desc: '최대 HP의 40%를 흡수하는 신성한 보호막을 생성합니다' },
                { name: '부활', icon: '👼', cost: 80, cooldown: 60, unlockLv: 8, desc: '1분간 부활 효과를 얻어, 사망 시 HP 50%로 부활합니다' },
                { name: '천상의 빛', icon: '☀️', cost: 60, cooldown: 15, unlockLv: 10, desc: 'HP를 완전히 회복하고 5초간 공격력 30% 증가 버프를 얻습니다. 궁극기' }
            ]
        },
        samurai: {
            name: '사무라이', icon: '⚔️', color: '#f97316',
            desc: '빠른 검술과 정확한 반격으로 적을 베어가는 검의 달인',
            hp: 120, mp: 80, atk: 24, def: 10, spd: 5, critRate: 0.20,
            attackType: 'melee', attackRange: 75,
            passive: { name: '검의 정신', desc: '연속 공격 시 타격당 피해량이 10%씩 증가합니다 (최대 100% 증가)', effect: 'swordSpirit' },
            skills: [
                { name: '발도술', icon: '🗡️', cost: 20, cooldown: 3, unlockLv: 1, desc: '번개같이 빠른 일섬으로 최대 3명에게 공격력의 200% 피해를 입힙니다' },
                { name: '카운터', icon: '🔄', cost: 15, cooldown: 5, unlockLv: 2, desc: '3초간 반격 태세. 이 동안 피격 시 피해를 무효화하고 공격자에게 2배 피해로 반격합니다' },
                { name: '검풍', icon: '💨', cost: 25, cooldown: 4, unlockLv: 4, desc: '검기를 날려 최대 10명을 관통하며 공격력의 200% 피해를 입힙니다' },
                { name: '무아지경', icon: '🧘', cost: 30, cooldown: 12, unlockLv: 6, desc: '5초간 완벽한 집중 상태에 돌입하여 모든 공격을 회피합니다' },
                { name: '오의: 십자참', icon: '✖️', cost: 45, cooldown: 10, unlockLv: 8, desc: '십자 형태로 베어 반경 150 내 모든 적에게 공격력의 300% 치명타 피해를 입힙니다' },
                { name: '오의: 천섬', icon: '⚡', cost: 70, cooldown: 18, unlockLv: 10, desc: '0.6초간 눈에 보이지 않는 속도로 20회 베어 총 공격력의 1000% 피해를 입힙니다. 궁극기' }
            ]
        }
    };

    // ============= UPGRADES =============
    const UPGRADES = [
        { id: 'atk', name: '공격력 강화', icon: '⚔️', desc: '+20% 공격력', color: '#ef4444', apply: p => p.atkMult += 0.2 },
        { id: 'hp', name: '체력 강화', icon: '❤️', desc: '+25% 최대 HP', color: '#22c55e', apply: p => { p.maxHp *= 1.25; p.hp = p.maxHp; }},
        { id: 'mp', name: '마나 강화', icon: '💎', desc: '+30% 최대 MP', color: '#3b82f6', apply: p => { p.maxMp *= 1.3; p.mp = p.maxMp; }},
        { id: 'spd', name: '이동속도', icon: '💨', desc: '+15% 이동속도', color: '#22d3ee', apply: p => p.spdMult += 0.15 },
        { id: 'crit', name: '치명타', icon: '🎯', desc: '+10% 치명타 확률', color: '#fbbf24', apply: p => p.critRate += 0.1 },
        { id: 'critdmg', name: '치명타 피해', icon: '💥', desc: '+40% 치명타 피해', color: '#f97316', apply: p => p.critDmg += 0.4 },
        { id: 'def', name: '방어력', icon: '🛡️', desc: '+30% 방어력', color: '#64748b', apply: p => p.defMult += 0.3 },
        { id: 'regen', name: 'HP 재생', icon: '💚', desc: '+5 HP/초 재생', color: '#10b981', apply: p => p.hpRegen += 5 },
        { id: 'mpregen', name: 'MP 재생', icon: '💙', desc: '+3 MP/초 재생', color: '#6366f1', apply: p => p.mpRegen += 3 },
        { id: 'lifesteal', name: '흡혈', icon: '🩸', desc: '피해량 8% 흡혈', color: '#dc2626', apply: p => p.lifesteal += 0.08 },
        { id: 'range', name: '사거리', icon: '🎪', desc: '+25% 공격 사거리', color: '#a855f7', apply: p => p.rangeMult += 0.25 },
        { id: 'aspd', name: '공격속도', icon: '⚡', desc: '+25% 공격속도', color: '#fcd34d', apply: p => p.aspdMult += 0.25 },
    ];

    // ============= ENHANCED AUDIO SYSTEM =============
    class AudioSystem {
        constructor() {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.3;
            this.masterGain.connect(this.ctx.destination);
            
            // Reverb for depth
            this.convolver = this.ctx.createConvolver();
            this.reverbGain = this.ctx.createGain();
            this.reverbGain.gain.value = 0.2;
            this.convolver.connect(this.reverbGain);
            this.reverbGain.connect(this.masterGain);
            this.createReverb();
            
            // Background music state
            this.bgmPlaying = false;
            this.bgmOscillators = [];
        }
        
        createReverb() {
            const rate = this.ctx.sampleRate;
            const length = rate * 2;
            const impulse = this.ctx.createBuffer(2, length, rate);
            for (let i = 0; i < 2; i++) {
                const channel = impulse.getChannelData(i);
                for (let j = 0; j < length; j++) {
                    channel[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / length, 2);
                }
            }
            this.convolver.buffer = impulse;
        }
        
        play(type, options = {}) {
            if (this.ctx.state === 'suspended') this.ctx.resume();
            
            const now = this.ctx.currentTime;
            
            switch(type) {
                case 'hit':
                    this.playHit(now, options);
                    break;
                case 'shoot':
                    this.playShoot(now, options);
                    break;
                case 'explosion':
                    this.playExplosion(now, options);
                    break;
                case 'levelup':
                    this.playLevelUp(now);
                    break;
                case 'pickup':
                    this.playPickup(now);
                    break;
                case 'dash':
                    this.playDash(now);
                    break;
                case 'skill':
                    this.playSkill(now, options);
                    break;
                case 'critical':
                    this.playCritical(now);
                    break;
                case 'boss':
                    this.playBossAppear(now);
                    break;
            }
        }
        
        createOsc(freq, type, gain, start, end) {
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            g.gain.value = 0;
            g.gain.setValueAtTime(gain, start);
            g.gain.exponentialRampToValueAtTime(0.001, end);
            osc.connect(g);
            g.connect(this.masterGain);
            g.connect(this.convolver);
            osc.start(start);
            osc.stop(end + 0.1);
            return osc;
        }
        
        playHit(now, opts = {}) {
            const intensity = opts.intensity || 1;
            // Impact thud
            this.createOsc(80 * intensity, 'sine', 0.3, now, now + 0.1);
            // High click
            this.createOsc(800, 'square', 0.05, now, now + 0.03);
            // Noise burst
            const noise = this.ctx.createBufferSource();
            const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.05, this.ctx.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
            noise.buffer = noiseBuffer;
            const noiseGain = this.ctx.createGain();
            noiseGain.gain.setValueAtTime(0.1 * intensity, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
            noise.connect(noiseGain);
            noiseGain.connect(this.masterGain);
            noise.start(now);
        }
        
        playShoot(now, opts = {}) {
            const pitch = opts.pitch || 1;
            // Laser sound
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(1200 * pitch, now);
            osc.frequency.exponentialRampToValueAtTime(200 * pitch, now + 0.15);
            g.gain.setValueAtTime(0.08, now);
            g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            osc.connect(g);
            g.connect(this.masterGain);
            osc.start(now);
            osc.stop(now + 0.2);
        }
        
        playExplosion(now, opts = {}) {
            const size = opts.size || 1;
            // Deep boom
            this.createOsc(40 * size, 'sine', 0.4, now, now + 0.3);
            this.createOsc(60 * size, 'triangle', 0.2, now, now + 0.25);
            // Noise
            const noise = this.ctx.createBufferSource();
            const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.4, this.ctx.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 1.5);
            }
            noise.buffer = noiseBuffer;
            const noiseGain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, now);
            filter.frequency.exponentialRampToValueAtTime(100, now + 0.4);
            noiseGain.gain.setValueAtTime(0.3 * size, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
            noise.connect(filter);
            filter.connect(noiseGain);
            noiseGain.connect(this.masterGain);
            noiseGain.connect(this.convolver);
            noise.start(now);
        }
        
        playLevelUp(now) {
            // Triumphant arpeggio
            const notes = [523, 659, 784, 1047];
            notes.forEach((freq, i) => {
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.value = freq;
                g.gain.setValueAtTime(0, now + i * 0.1);
                g.gain.linearRampToValueAtTime(0.15, now + i * 0.1 + 0.05);
                g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.4);
                osc.connect(g);
                g.connect(this.masterGain);
                g.connect(this.convolver);
                osc.start(now + i * 0.1);
                osc.stop(now + i * 0.1 + 0.5);
            });
            // Shimmer
            for (let i = 0; i < 3; i++) {
                this.createOsc(2000 + i * 500, 'sine', 0.03, now + 0.3, now + 0.8);
            }
        }
        
        playPickup(now) {
            // Coin-like sound
            this.createOsc(1200, 'sine', 0.1, now, now + 0.1);
            this.createOsc(1800, 'sine', 0.08, now + 0.05, now + 0.15);
        }
        
        playDash(now) {
            // Whoosh
            const noise = this.ctx.createBufferSource();
            const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
            noise.buffer = noiseBuffer;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(500, now);
            filter.frequency.exponentialRampToValueAtTime(2000, now + 0.1);
            filter.frequency.exponentialRampToValueAtTime(300, now + 0.2);
            filter.Q.value = 2;
            const g = this.ctx.createGain();
            g.gain.setValueAtTime(0.15, now);
            g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            noise.connect(filter);
            filter.connect(g);
            g.connect(this.masterGain);
            noise.start(now);
        }
        
        playSkill(now, opts = {}) {
            const element = opts.element || 'fire';
            const colors = {
                fire: { base: 300, mod: 'sawtooth' },
                ice: { base: 800, mod: 'sine' },
                lightning: { base: 1500, mod: 'square' },
                holy: { base: 600, mod: 'triangle' },
                dark: { base: 100, mod: 'sawtooth' }
            };
            const c = colors[element] || colors.fire;
            
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.type = c.mod;
            osc.frequency.setValueAtTime(c.base, now);
            osc.frequency.exponentialRampToValueAtTime(c.base * 2, now + 0.1);
            osc.frequency.exponentialRampToValueAtTime(c.base * 0.5, now + 0.3);
            g.gain.setValueAtTime(0.12, now);
            g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            osc.connect(g);
            g.connect(this.masterGain);
            g.connect(this.convolver);
            osc.start(now);
            osc.stop(now + 0.4);
        }
        
        playCritical(now) {
            // Sharp critical hit
            this.createOsc(1000, 'square', 0.1, now, now + 0.05);
            this.createOsc(1500, 'sawtooth', 0.08, now + 0.02, now + 0.1);
            this.playHit(now, { intensity: 1.5 });
        }
        
        playBossAppear(now) {
            // Ominous horn
            for (let i = 0; i < 3; i++) {
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.value = 80 + i * 40;
                g.gain.setValueAtTime(0, now);
                g.gain.linearRampToValueAtTime(0.1, now + 0.3);
                g.gain.setValueAtTime(0.1, now + 0.8);
                g.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
                osc.connect(g);
                g.connect(this.masterGain);
                g.connect(this.convolver);
                osc.start(now);
                osc.stop(now + 1.6);
            }
        }
        
        // Background ambient music
        startBGM() {
            if (this.bgmPlaying) return;
            this.bgmPlaying = true;
            
            const now = this.ctx.currentTime;
            
            // Ambient pad
            const padNotes = [130.81, 164.81, 196]; // C3, E3, G3
            padNotes.forEach((freq, i) => {
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                osc.type = 'sine';
                osc.frequency.value = freq;
                
                filter.type = 'lowpass';
                filter.frequency.value = 400;
                
                g.gain.value = 0.03;
                
                // LFO for gentle movement
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                lfo.frequency.value = 0.1 + i * 0.05;
                lfoGain.gain.value = 0.01;
                lfo.connect(lfoGain);
                lfoGain.connect(g.gain);
                
                osc.connect(filter);
                filter.connect(g);
                g.connect(this.masterGain);
                
                osc.start(now);
                lfo.start(now);
                
                this.bgmOscillators.push(osc, lfo);
            });
        }
        
        stopBGM() {
            this.bgmOscillators.forEach(osc => {
                try { osc.stop(); } catch(e) {}
            });
            this.bgmOscillators = [];
            this.bgmPlaying = false;
        }
        
        setVolume(v) {
            this.masterGain.gain.value = v;
        }
    }
    const audio = new AudioSystem();

    // ============= STAGES DEFINITION =============
    const STAGES = [
        { id: 'grassland', name: '🌲 초원 스테이지', color: '#4ade80', bgColor: '#1a2e1a', 
          desc: '평화로운 초원 지대', enemies: ['slime', 'goblin'], boss: 'boss_dragon' },
        { id: 'desert', name: '🏜️ 사막 스테이지', color: '#fbbf24', bgColor: '#2e2a1a',
          desc: '뜨거운 사막 지대', enemies: ['skeleton', 'demon'], boss: 'boss_lich' },
        { id: 'snow', name: '❄️ 설산 스테이지', color: '#22d3ee', bgColor: '#1a2a2e',
          desc: '얼어붙은 설산 지대', enemies: ['ghost', 'vampire'], boss: 'boss_titan' },
        { id: 'volcano', name: '🌋 화산 스테이지', color: '#ef4444', bgColor: '#2e1a1a',
          desc: '불타는 화산 지대', enemies: ['demon', 'orc'], boss: 'boss_dragon' },
        { id: 'abyss', name: '🌑 심연 스테이지', color: '#a855f7', bgColor: '#1a1a2e',
          desc: '어둠의 심연 지대', enemies: ['ghost', 'vampire', 'skeleton'], boss: 'boss_lich' }
    ];

    // ============= WEATHER SYSTEM =============
    const WEATHER_TYPES = {
        clear: { name: '맑음', icon: '☀️', effects: {} },
        rain: { name: '비', icon: '🌧️', effects: { playerSpd: 0.9, visibility: 0.8 } },
        snow: { name: '눈', icon: '❄️', effects: { playerSpd: 0.85, enemySpd: 0.9 } },
        fog: { name: '안개', icon: '🌫️', effects: { visibility: 0.5 } },
        storm: { name: '폭풍', icon: '⛈️', effects: { playerSpd: 0.8, visibility: 0.6, randomLightning: true } }
    };

    // ============= TIME SYSTEM =============
    const TIME_PHASES = {
        dawn: { name: '새벽', icon: '🌅', brightness: 0.7, enemyMult: 0.8 },
        day: { name: '낮', icon: '☀️', brightness: 1.0, enemyMult: 1.0 },
        dusk: { name: '황혼', icon: '🌇', brightness: 0.7, enemyMult: 1.2 },
        night: { name: '밤', icon: '🌙', brightness: 0.4, enemyMult: 1.5 }
    };

    // ============= BOSS GIMMICKS =============
    const BOSS_GIMMICKS = {
        boss_dragon: [
            { name: '화염 폭풍', desc: '바닥에 화염 지대 생성! 피하세요!', type: 'fire_zone' },
            { name: '비상', desc: '드래곤이 하늘로 날아올라 낙하 공격 준비!', type: 'fly_attack' },
            { name: '브레스', desc: '전방 180도 화염 브레스! 뒤로 피하세요!', type: 'breath' }
        ],
        boss_lich: [
            { name: '영혼 폭발', desc: '주변에 폭발하는 영혼 생성!', type: 'soul_explosion' },
            { name: '소환', desc: '대량의 해골 병사 소환!', type: 'mass_summon' },
            { name: '저주 장판', desc: '저주 지대 생성! 밟으면 지속 피해!', type: 'curse_zone' }
        ],
        boss_titan: [
            { name: '지진', desc: '땅이 흔들립니다! 점프하세요!', type: 'earthquake' },
            { name: '돌진', desc: '타이탄이 돌진합니다! 옆으로 피하세요!', type: 'charge' },
            { name: '분노', desc: '분노 상태! 공격력과 속도 증가!', type: 'enrage' }
        ]
    };

    // ============= SKILL TREE =============
    const SKILL_TREE = {
        offense: [
            { id: 'power1', name: '공격력 I', icon: '⚔️', maxLv: 5, effect: p => p.atkMult += 0.05, desc: '공격력 +5%' },
            { id: 'crit1', name: '치명타 I', icon: '🎯', maxLv: 5, effect: p => p.critRate += 0.02, desc: '치명타 +2%' },
            { id: 'aspd1', name: '공격속도 I', icon: '⚡', maxLv: 3, effect: p => p.aspdMult += 0.1, desc: '공격속도 +10%' }
        ],
        defense: [
            { id: 'hp1', name: '체력 I', icon: '❤️', maxLv: 5, effect: p => { p.maxHp *= 1.05; p.hp = p.maxHp; }, desc: '최대 HP +5%' },
            { id: 'def1', name: '방어력 I', icon: '🛡️', maxLv: 5, effect: p => p.defMult += 0.05, desc: '방어력 +5%' },
            { id: 'regen1', name: 'HP재생 I', icon: '💚', maxLv: 3, effect: p => p.hpRegen += 1, desc: 'HP재생 +1' }
        ],
        utility: [
            { id: 'spd1', name: '이동속도 I', icon: '💨', maxLv: 3, effect: p => p.spdMult += 0.05, desc: '이동속도 +5%' },
            { id: 'mp1', name: '마나 I', icon: '💎', maxLv: 5, effect: p => { p.maxMp *= 1.05; p.mp = p.maxMp; }, desc: '최대 MP +5%' },
            { id: 'mpregen1', name: 'MP재생 I', icon: '💙', maxLv: 3, effect: p => p.mpRegen += 0.5, desc: 'MP재생 +0.5' }
        ]
    };

    // ============= GAME STATE =============
    let game = {
        running: false,
        paused: false,
        selectedClass: 'warrior',
        player: null,
        enemies: [],
        projectiles: [],
        particles: [],
        loot: [],
        summons: [],
        traps: [],
        floatingTexts: [],
        camera: { x: 0, y: 0, shake: 0 },
        wave: 1,
        waveTimer: 0,
        tick: 0,
        startTime: 0,
        input: { keys: {}, mouse: { x: 0, y: 0, down: false, right: false } },
        terrain: [],
        trees: [],
        decorations: [],
        // New systems
        currentStage: 0,
        stageKills: 0,
        stageKillsNeeded: 30,
        timeOfDay: 'day',
        timeCounter: 0,
        weather: 'clear',
        weatherTimer: 0,
        skillPoints: 0,
        skillTreeLevels: {},
        bossGimmickActive: false,
        bossGimmickData: null,
        hazardZones: [],
        dayNightCycle: 0
    };

    // ============= TERRAIN GENERATION =============
    function generateTerrain() {
        game.terrain = [];
        game.trees = [];
        game.decorations = [];
        
        // Generate grass patches
        for (let i = 0; i < 200; i++) {
            game.decorations.push({
                x: rand(0, WORLD_W),
                y: rand(0, WORLD_H),
                type: 'grass',
                size: rand(10, 25),
                color: `hsl(${randInt(100, 140)}, ${randInt(40, 60)}%, ${randInt(25, 40)}%)`
            });
        }
        
        // Generate flowers
        for (let i = 0; i < 100; i++) {
            game.decorations.push({
                x: rand(0, WORLD_W),
                y: rand(0, WORLD_H),
                type: 'flower',
                color: ['#f472b6', '#fbbf24', '#a855f7', '#3b82f6', '#ef4444'][randInt(0, 4)]
            });
        }
        
        // Generate trees
        for (let i = 0; i < 80; i++) {
            game.trees.push({
                x: rand(100, WORLD_W - 100),
                y: rand(100, WORLD_H - 100),
                size: rand(30, 60),
                trunkColor: `hsl(30, ${randInt(30, 50)}%, ${randInt(20, 35)}%)`,
                leafColor: `hsl(${randInt(100, 150)}, ${randInt(50, 70)}%, ${randInt(30, 45)}%)`
            });
        }
        
        // Generate water pools
        for (let i = 0; i < 8; i++) {
            game.terrain.push({
                x: rand(200, WORLD_W - 200),
                y: rand(200, WORLD_H - 200),
                type: 'water',
                radius: rand(60, 150)
            });
        }
        
        // Generate rocks
        for (let i = 0; i < 50; i++) {
            game.terrain.push({
                x: rand(0, WORLD_W),
                y: rand(0, WORLD_H),
                type: 'rock',
                size: rand(15, 40),
                color: `hsl(0, 0%, ${randInt(30, 50)}%)`
            });
        }
        
        // Generate paths
        for (let i = 0; i < 5; i++) {
            const startX = rand(100, WORLD_W - 100);
            const startY = rand(100, WORLD_H - 100);
            let x = startX, y = startY;
            for (let j = 0; j < 20; j++) {
                game.decorations.push({
                    x: x, y: y,
                    type: 'path',
                    size: rand(30, 50)
                });
                x += rand(-60, 60);
                y += rand(-60, 60);
            }
        }
    }

    // ============= PLAYER CLASS =============
    class Player {
        constructor(classType) {
            const c = CLASSES[classType];
            this.classType = classType;
            this.className = c.name;
            this.icon = c.icon;
            this.color = c.color;
            
            this.x = WORLD_W / 2;
            this.y = WORLD_H / 2;
            this.radius = 18;
            this.angle = 0;
            
            // Base stats
            this.maxHp = c.hp;
            this.hp = c.hp;
            this.maxMp = c.mp;
            this.mp = c.mp;
            this.baseAtk = c.atk;
            this.baseDef = c.def;
            this.baseSpd = c.spd;
            this.critRate = c.critRate;
            this.critDmg = 2.0;
            
            this.attackType = c.attackType;
            this.attackRange = c.attackRange;
            
            // Multipliers
            this.atkMult = 1;
            this.defMult = 1;
            this.spdMult = 1;
            this.aspdMult = 1;
            this.rangeMult = 1;
            
            // Regen
            this.hpRegen = 1;
            this.mpRegen = 2;
            this.lifesteal = 0;
            
            // Combat
            this.attackCooldown = 0;
            this.attackCooldownMax = 20;
            this.invincible = 0;
            
            // Dash
            this.dashCooldown = 0;
            this.dashCooldownMax = 90;
            this.isDashing = false;
            this.dashTime = 0;
            this.dashDir = { x: 0, y: 0 };
            
            // Progression
            this.level = 1;
            this.exp = 0;
            this.nextExp = 100;
            this.kills = 0;
            this.gold = 0;
            this.combo = 0;
            this.maxCombo = 0;
            this.comboTimer = 0;
            
            // Skills
            this.skills = c.skills.map((s, i) => ({
                ...s,
                index: i,
                cooldownTimer: 0
            }));
            
            // Passive
            this.passive = c.passive;
            
            // Buffs
            this.buffs = [];
            
            // Special states
            this.invisible = false;
            this.counterStance = false;
            this.shield = 0;
            this.hasResurrect = false;
            
            // For samurai combo
            this.consecutiveHits = 0;
        }
        
        get atk() { 
            let a = this.baseAtk * this.atkMult;
            // Berserker rage passive
            if (this.passive.effect === 'rage') {
                const hpPercent = this.hp / this.maxHp;
                a *= 1 + (1 - hpPercent) * 1.5;
            }
            // Samurai consecutive hits
            if (this.passive.effect === 'swordSpirit') {
                a *= 1 + Math.min(this.consecutiveHits * 0.1, 1);
            }
            return Math.floor(a);
        }
        
        get def() { 
            let d = this.baseDef * this.defMult;
            // Warrior iron will
            if (this.passive.effect === 'ironWill' && this.hp / this.maxHp <= 0.2) {
                d *= 2;
            }
            return Math.floor(d);
        }
        
        get spd() { return this.baseSpd * this.spdMult; }
        get range() { return this.attackRange * this.rangeMult; }
        
        update() {
            // Regen
            if (game.tick % 60 === 0) {
                let hpReg = this.hpRegen;
                let mpReg = this.mpRegen;
                if (this.passive.effect === 'manaAffinity') mpReg *= 3;
                this.hp = Math.min(this.maxHp, this.hp + hpReg);
                this.mp = Math.min(this.maxMp, this.mp + mpReg);
            }
            
            // Combo decay
            if (this.comboTimer > 0) {
                this.comboTimer--;
                if (this.comboTimer <= 0) {
                    this.maxCombo = Math.max(this.maxCombo, this.combo);
                    this.combo = 0;
                    this.consecutiveHits = 0;
                }
            }
            
            // Buffs
            this.buffs = this.buffs.filter(b => {
                b.duration--;
                return b.duration > 0;
            });
            
            // Cooldowns
            if (this.attackCooldown > 0) this.attackCooldown--;
            if (this.dashCooldown > 0) this.dashCooldown--;
            if (this.invincible > 0) this.invincible--;
            
            this.skills.forEach(s => {
                if (s.cooldownTimer > 0) s.cooldownTimer--;
            });
            
            // Movement
            let dx = 0, dy = 0;
            const keys = game.input.keys;
            if (keys['w'] || keys['W'] || keys['ArrowUp']) dy = -1;
            if (keys['s'] || keys['S'] || keys['ArrowDown']) dy = 1;
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) dx = -1;
            if (keys['d'] || keys['D'] || keys['ArrowRight']) dx = 1;
            
            // Dash
            if ((keys['Shift'] || game.input.mouse.right) && this.dashCooldown <= 0 && (dx || dy)) {
                this.startDash(dx, dy);
            }
            
            if (this.isDashing) {
                this.dashTime--;
                if (this.dashTime <= 0) this.isDashing = false;
                dx = this.dashDir.x;
                dy = this.dashDir.y;
                
                // Dash particles
                game.particles.push(createParticle(this.x, this.y, this.color, 8, 15));
            }
            
            if (dx || dy) {
                const len = Math.hypot(dx, dy);
                const speed = this.isDashing ? 18 : this.spd;
                this.x += (dx / len) * speed;
                this.y += (dy / len) * speed;
            }
            
            // Bounds
            this.x = clamp(this.x, this.radius, WORLD_W - this.radius);
            this.y = clamp(this.y, this.radius, WORLD_H - this.radius);
            
            // Aim
            const worldMouse = screenToWorld(game.input.mouse.x, game.input.mouse.y);
            this.angle = Math.atan2(worldMouse.y - this.y, worldMouse.x - this.x);
            
            // Attack
            if (game.input.mouse.down && this.attackCooldown <= 0) {
                this.attack();
            }
            
            // Skill keys
            for (let i = 1; i <= 6; i++) {
                if (keys[String(i)]) {
                    this.useSkill(i - 1);
                    keys[String(i)] = false;
                }
            }
        }
        
        startDash(dx, dy) {
            const len = Math.hypot(dx, dy);
            this.dashDir = { x: dx / len, y: dy / len };
            this.isDashing = true;
            this.dashTime = 8;
            this.dashCooldown = this.dashCooldownMax;
            
            // Enhanced dash effects
            audio.play('dash');
            game.camera.shake = 5;
            
            // Dash start burst
            const burstParticles = createSparkBurst(this.x, this.y, this.color, 12);
            burstParticles.forEach(p => game.particles.push(p));
            
            // Initial flash
            game.particles.push(createParticle(this.x, this.y, '#fff', 25, 10, {
                vx: 0, vy: 0, type: 'flash'
            }));
        }
        
        attack() {
            this.attackCooldown = Math.floor(this.attackCooldownMax / this.aspdMult);
            
            if (this.attackType === 'melee') {
                // Enhanced melee slash with multiple layers
                game.particles.push(createSlash(this.x, this.y, this.angle, this.range, this.color, {
                    thickness: 8,
                    arc: 1.0,
                    secondary: '#fff',
                    trail: true
                }));
                
                // Additional slash trail
                game.particles.push(createSlash(this.x, this.y, this.angle, this.range * 0.8, '#fff', {
                    thickness: 3,
                    arc: 0.8,
                    life: 10
                }));
                
                // Swing particles
                for (let i = 0; i < 8; i++) {
                    const a = this.angle + rand(-0.5, 0.5);
                    const r = rand(20, this.range);
                    game.particles.push(createParticle(
                        this.x + Math.cos(a) * r,
                        this.y + Math.sin(a) * r,
                        this.color, rand(2, 5), rand(10, 20), {
                            vx: Math.cos(a) * rand(1, 3),
                            vy: Math.sin(a) * rand(1, 3),
                            type: 'spark',
                            trail: true
                        }
                    ));
                }
                
                audio.play('hit', { intensity: 1 });
                
                game.enemies.forEach(e => {
                    const d = dist(this, e);
                    if (d < this.range + e.radius) {
                        const aToE = Math.atan2(e.y - this.y, e.x - this.x);
                        let diff = aToE - this.angle;
                        while (diff > Math.PI) diff -= Math.PI * 2;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        if (Math.abs(diff) < Math.PI / 2) {
                            this.dealDamage(e, 1);
                        }
                    }
                });
            } else {
                // Enhanced ranged projectile
                game.projectiles.push(createProjectile(
                    this.x, this.y, this.angle, 
                    { damage: this.atk, color: this.color, fromPlayer: true, glow: true }
                ));
                
                // Muzzle flash
                game.particles.push(createParticle(
                    this.x + Math.cos(this.angle) * 20,
                    this.y + Math.sin(this.angle) * 20,
                    this.color, 15, 8, { vx: 0, vy: 0, type: 'flash' }
                ));
                
                // Shell casings effect (for ranger)
                if (this.classType === 'ranger') {
                    for (let i = 0; i < 3; i++) {
                        game.particles.push(createParticle(
                            this.x, this.y, '#ffd700', rand(2, 4), 25, {
                                vx: Math.cos(this.angle - Math.PI/2) * rand(1, 3),
                                vy: rand(-2, -1),
                                gravity: 0.2,
                                type: 'spark'
                            }
                        ));
                    }
                }
                
                audio.play('shoot', { pitch: this.classType === 'mage' ? 0.7 : 1 });
            }
        }
        
        dealDamage(enemy, mult = 1) {
            const isCrit = Math.random() < this.critRate;
            let critMult = isCrit ? this.critDmg : 1;
            
            // Sharpshooter passive
            if (this.passive.effect === 'sharpshooter' && isCrit) {
                critMult += 0.5;
            }
            
            // Buff bonuses
            const atkBuff = this.buffs.find(b => b.type === 'atk');
            const buffMult = atkBuff ? atkBuff.value : 1;
            
            let dmg = Math.floor(this.atk * mult * critMult * buffMult);
            
            // Backstab passive
            if (this.passive.effect === 'backstab') {
                const behind = Math.abs(this.angle - enemy.angle) < Math.PI / 2;
                if (behind) dmg *= 2;
            }
            
            enemy.takeDamage(dmg, isCrit, this.angle);
            
            // Lifesteal
            if (this.lifesteal > 0) {
                this.hp = Math.min(this.maxHp, this.hp + dmg * this.lifesteal);
            }
            
            // Combo
            this.combo++;
            this.consecutiveHits++;
            this.comboTimer = 120;
            
            game.camera.shake = 4;
        }
        
        useSkill(index) {
            const skill = this.skills[index];
            if (!skill) return;
            if (skill.unlockLv > this.level) return;
            if (skill.cooldownTimer > 0) return;
            if (this.mp < skill.cost) return;
            
            this.mp -= skill.cost;
            skill.cooldownTimer = skill.cooldown * 60;
            
            this.executeSkill(skill);
        }
        
        getSkillElement() {
            const elementMap = {
                'warrior': 'fire',
                'mage': 'fire',
                'ranger': 'lightning',
                'assassin': 'dark',
                'paladin': 'holy',
                'necromancer': 'dark',
                'berserker': 'fire',
                'elementalist': 'ice',
                'priest': 'holy',
                'samurai': 'lightning'
            };
            return elementMap[this.classType] || 'fire';
        }
        
        executeSkill(skill) {
            const worldMouse = screenToWorld(game.input.mouse.x, game.input.mouse.y);
            
            // Universal skill activation effect
            const skillParticles = createMagicEffect(this.x, this.y, this.color, this.getSkillElement());
            skillParticles.forEach(p => game.particles.push(p));
            
            switch(this.classType) {
                case 'warrior':
                    if (skill.name === '강타') {
                        this.meleeAOE(1.5, 2);
                        audio.play('skill', { element: 'fire' });
                    } else if (skill.name === '방패 올리기') {
                        this.invincible = 180;
                        this.buffs.push({ type: 'shield', icon: '🛡️', duration: 180, color: '#3b82f6' });
                        game.particles.push(createRingEffect(this.x, this.y, '#3b82f6', 60));
                        audio.play('skill', { element: 'holy' });
                    } else if (skill.name === '회오리') {
                        this.spinAttack(1.5);
                        audio.play('skill', { element: 'fire' });
                    } else if (skill.name === '전사의 함성') {
                        this.buffs.push({ type: 'atk', icon: '📢', duration: 300, value: 1.5, color: '#ef4444' });
                        game.particles.push(createRingEffect(this.x, this.y, '#ef4444', 100));
                        audio.play('skill', { element: 'fire' });
                    } else if (skill.name === '지진') {
                        this.groundSlam(200, 3);
                        audio.play('explosion', { size: 1.5 });
                    } else if (skill.name === '불멸의 의지') {
                        this.invincible = 300;
                        this.buffs.push({ type: 'atk', icon: '👊', duration: 300, value: 2, color: '#fbbf24' });
                        // Epic activation effect
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                game.particles.push(createRingEffect(this.x, this.y, '#fbbf24', 80 + i * 40));
                            }, i * 100);
                        }
                        audio.play('skill', { element: 'holy' });
                    }
                    break;
                    
                case 'mage':
                    if (skill.name === '파이어볼') {
                        this.fireProjectile(worldMouse, { type: 'fireball', damage: this.atk * 2, radius: 12, explode: true });
                    } else if (skill.name === '아이스 샤드') {
                        this.fireProjectile(worldMouse, { type: 'ice', damage: this.atk * 1.5, freeze: true });
                    } else if (skill.name === '번개') {
                        this.chainLightning(3);
                    } else if (skill.name === '텔레포트') {
                        this.teleport(worldMouse);
                    } else if (skill.name === '메테오') {
                        this.meteor(worldMouse, 120, 4);
                    } else if (skill.name === '아마겟돈') {
                        this.armageddon();
                    }
                    break;
                    
                case 'ranger':
                    if (skill.name === '멀티샷') {
                        for (let i = -2; i <= 2; i++) {
                            game.projectiles.push(createProjectile(this.x, this.y, this.angle + i * 0.2, 
                                { damage: this.atk, color: this.color, fromPlayer: true }));
                        }
                    } else if (skill.name === '독화살') {
                        this.fireProjectile(worldMouse, { type: 'poison', damage: this.atk, poison: true });
                    } else if (skill.name === '회피 사격') {
                        this.x -= Math.cos(this.angle) * 80;
                        this.y -= Math.sin(this.angle) * 80;
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                game.projectiles.push(createProjectile(this.x, this.y, this.angle, 
                                    { damage: this.atk, color: this.color, fromPlayer: true }));
                            }, i * 100);
                        }
                    } else if (skill.name === '덫') {
                        game.traps.push({ x: this.x, y: this.y, radius: 80, duration: 600, slow: 0.3 });
                    } else if (skill.name === '화살 비') {
                        this.arrowRain(worldMouse);
                    } else if (skill.name === '저격') {
                        this.snipe(worldMouse);
                    }
                    break;
                    
                case 'assassin':
                    if (skill.name === '그림자 베기') {
                        for (let i = 0; i < 2; i++) {
                            setTimeout(() => this.meleeAOE(1, 1.2), i * 100);
                        }
                    } else if (skill.name === '은신') {
                        this.invisible = true;
                        this.buffs.push({ type: 'invisible', icon: '👤', duration: 180, color: '#6366f1' });
                        setTimeout(() => this.invisible = false, 3000);
                    } else if (skill.name === '독 칼날') {
                        this.poisonBlade();
                    } else if (skill.name === '그림자 이동') {
                        this.shadowStep();
                    } else if (skill.name === '암살') {
                        this.assassinate();
                    } else if (skill.name === '죽음의 춤') {
                        this.deathDance();
                    }
                    break;
                    
                case 'paladin':
                    if (skill.name === '신성한 일격') {
                        this.holyStrike();
                    } else if (skill.name === '치유의 빛') {
                        const heal = this.maxHp * 0.3;
                        this.hp = Math.min(this.maxHp, this.hp + heal);
                        spawnFloatingText(this.x, this.y, `+${Math.floor(heal)}`, '#22c55e');
                    } else if (skill.name === '심판') {
                        this.judgement();
                    } else if (skill.name === '신성 보호막') {
                        this.shield = this.maxHp * 0.5;
                        this.buffs.push({ type: 'holyShield', icon: '🔰', duration: 300, color: '#fbbf24' });
                    } else if (skill.name === '천벌') {
                        this.divineWrath(worldMouse);
                    } else if (skill.name === '대천사 소환') {
                        this.summonAngel();
                    }
                    break;
                    
                case 'necromancer':
                    if (skill.name === '저주') {
                        this.curse(worldMouse);
                    } else if (skill.name === '해골 소환') {
                        this.summonSkeleton();
                    } else if (skill.name === '생명력 흡수') {
                        this.lifeDrain();
                    } else if (skill.name === '공포') {
                        this.fear();
                    } else if (skill.name === '역병') {
                        this.plague();
                    } else if (skill.name === '죽음의 군대') {
                        for (let i = 0; i < 5; i++) this.summonSkeleton();
                    }
                    break;
                    
                case 'berserker':
                    if (skill.name === '분노의 일격') {
                        this.meleeAOE(1.5, 1.5);
                    } else if (skill.name === '포효') {
                        this.roar();
                    } else if (skill.name === '피의 칼날') {
                        this.hp -= this.maxHp * 0.1;
                        this.meleeAOE(2, 3);
                    } else if (skill.name === '광폭화') {
                        this.buffs.push({ type: 'aspd', icon: '😈', duration: 300, value: 2, color: '#dc2626' });
                        this.aspdMult *= 2;
                        setTimeout(() => this.aspdMult /= 2, 5000);
                    } else if (skill.name === '처형') {
                        this.execute();
                    } else if (skill.name === '지옥불') {
                        this.hp -= this.maxHp * 0.3;
                        this.groundSlam(250, 5);
                    }
                    break;
                    
                case 'elementalist':
                    if (skill.name === '워터볼') {
                        this.fireProjectile(worldMouse, { type: 'water', damage: this.atk * 1.2, slow: true });
                    } else if (skill.name === '화염 폭발') {
                        this.meteor(worldMouse, 80, 2);
                    } else if (skill.name === '바람 칼날') {
                        this.fireProjectile(worldMouse, { type: 'wind', damage: this.atk * 1.5, pierce: 5 });
                    } else if (skill.name === '대지 진동') {
                        this.groundSlam(150, 1.5);
                        game.enemies.forEach(e => {
                            if (dist(this, e) < 150) e.stunned = 120;
                        });
                    } else if (skill.name === '폭풍 소환') {
                        this.summonStorm(worldMouse);
                    } else if (skill.name === '원소 융합') {
                        this.elementalFusion();
                    }
                    break;
                    
                case 'priest':
                    if (skill.name === '신성 화살') {
                        this.fireProjectile(worldMouse, { type: 'holy', damage: this.atk * 1.2 });
                    } else if (skill.name === '치유') {
                        let heal = this.maxHp * 0.4;
                        if (this.passive.effect === 'holyPower') heal *= 1.5;
                        this.hp = Math.min(this.maxHp, this.hp + heal);
                        spawnFloatingText(this.x, this.y, `+${Math.floor(heal)}`, '#22c55e');
                    } else if (skill.name === '정화') {
                        this.buffs = this.buffs.filter(b => b.type !== 'debuff');
                    } else if (skill.name === '보호막') {
                        this.shield = this.maxHp * 0.4;
                    } else if (skill.name === '부활') {
                        this.hasResurrect = true;
                        this.buffs.push({ type: 'resurrect', icon: '👼', duration: 3600, color: '#fbbf24' });
                    } else if (skill.name === '천상의 빛') {
                        this.hp = this.maxHp;
                        this.buffs.push({ type: 'atk', icon: '☀️', duration: 300, value: 1.3, color: '#fbbf24' });
                    }
                    break;
                    
                case 'samurai':
                    if (skill.name === '발도술') {
                        this.quickDraw();
                    } else if (skill.name === '카운터') {
                        this.counterStance = true;
                        this.buffs.push({ type: 'counter', icon: '🔄', duration: 180, color: '#f97316' });
                        setTimeout(() => this.counterStance = false, 3000);
                    } else if (skill.name === '검풍') {
                        this.swordWind();
                    } else if (skill.name === '무아지경') {
                        this.invincible = 300;
                        this.buffs.push({ type: 'dodge', icon: '🧘', duration: 300, color: '#a855f7' });
                    } else if (skill.name === '오의: 십자참') {
                        this.crossSlash();
                    } else if (skill.name === '오의: 천섬') {
                        this.thousandCuts();
                    }
                    break;
            }
        }
        
        // Skill helper methods
        meleeAOE(rangeMult, dmgMult) {
            game.particles.push(createSlash(this.x, this.y, this.angle, this.range * rangeMult, this.color));
            game.enemies.forEach(e => {
                if (dist(this, e) < this.range * rangeMult) {
                    this.dealDamage(e, dmgMult);
                }
            });
        }
        
        spinAttack(dmgMult) {
            for (let i = 0; i < 8; i++) {
                const a = (i / 8) * Math.PI * 2;
                game.particles.push(createSlash(this.x, this.y, a, this.range, this.color));
            }
            game.enemies.forEach(e => {
                if (dist(this, e) < this.range + e.radius) {
                    this.dealDamage(e, dmgMult);
                }
            });
        }
        
        groundSlam(radius, dmgMult) {
            for (let i = 0; i < 20; i++) {
                game.particles.push(createParticle(
                    this.x + rand(-radius, radius),
                    this.y + rand(-radius, radius),
                    this.color, rand(5, 15), 30
                ));
            }
            game.enemies.forEach(e => {
                if (dist(this, e) < radius) {
                    this.dealDamage(e, dmgMult);
                }
            });
            game.camera.shake = 10;
            audio.play('explosion');
        }
        
        fireProjectile(target, opts) {
            const a = Math.atan2(target.y - this.y, target.x - this.x);
            let dmg = opts.damage || this.atk;
            if (this.passive.effect === 'elementalMastery') dmg *= 1.25;
            game.projectiles.push(createProjectile(this.x, this.y, a, {
                ...opts, damage: dmg, color: this.color, fromPlayer: true
            }));
        }
        
        teleport(target) {
            for (let i = 0; i < 15; i++) {
                game.particles.push(createParticle(this.x, this.y, '#a855f7', 5, 20));
            }
            this.x = clamp(target.x, 50, WORLD_W - 50);
            this.y = clamp(target.y, 50, WORLD_H - 50);
            for (let i = 0; i < 15; i++) {
                game.particles.push(createParticle(this.x, this.y, '#a855f7', 5, 20));
            }
        }
        
        meteor(target, radius, dmgMult) {
            setTimeout(() => {
                for (let i = 0; i < 30; i++) {
                    game.particles.push(createParticle(
                        target.x + rand(-radius, radius),
                        target.y + rand(-radius, radius),
                        '#f97316', rand(8, 20), 40
                    ));
                }
                game.enemies.forEach(e => {
                    if (dist(target, e) < radius) {
                        e.takeDamage(this.atk * dmgMult, false, 0);
                    }
                });
                game.camera.shake = 12;
                audio.play('explosion');
            }, 500);
        }
        
        chainLightning(bounces) {
            let targets = [...game.enemies].sort((a, b) => dist(this, a) - dist(this, b));
            let lastPos = this;
            for (let i = 0; i < Math.min(bounces, targets.length); i++) {
                const t = targets[i];
                if (dist(lastPos, t) < 300) {
                    t.takeDamage(this.atk * 1.5, false, 0);
                    for (let j = 0; j < 5; j++) {
                        game.particles.push(createParticle(t.x, t.y, '#fbbf24', 4, 15));
                    }
                    lastPos = t;
                }
            }
        }
        
        armageddon() {
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const x = this.x + rand(-300, 300);
                    const y = this.y + rand(-300, 300);
                    this.meteor({ x, y }, 80, 2);
                }, i * 200);
            }
        }
        
        arrowRain(target) {
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    const x = target.x + rand(-100, 100);
                    const y = target.y + rand(-100, 100);
                    game.enemies.forEach(e => {
                        if (dist({ x, y }, e) < 30) {
                            e.takeDamage(this.atk, false, 0);
                        }
                    });
                    game.particles.push(createParticle(x, y, '#22c55e', 5, 20));
                }, i * 50);
            }
        }
        
        snipe(target) {
            const nearest = game.enemies.reduce((best, e) => {
                const d = dist(target, e);
                return (!best || d < dist(target, best)) ? e : best;
            }, null);
            if (nearest && dist(this, nearest) < 500) {
                nearest.takeDamage(this.atk * 5, true, this.angle);
                game.camera.shake = 8;
            }
        }
        
        shadowStep() {
            const nearest = game.enemies.reduce((best, e) => {
                const d = dist(this, e);
                return (!best || d < dist(this, best)) ? e : best;
            }, null);
            if (nearest) {
                this.x = nearest.x - Math.cos(nearest.angle) * 40;
                this.y = nearest.y - Math.sin(nearest.angle) * 40;
            }
        }
        
        assassinate() {
            this.meleeAOE(1, 4);
        }
        
        deathDance() {
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    this.angle = rand(0, Math.PI * 2);
                    this.meleeAOE(1.2, 1.5);
                }, i * 150);
            }
        }
        
        poisonBlade() {
            this.buffs.push({ type: 'poisonBlade', icon: '💚', duration: 300, color: '#22c55e' });
        }
        
        holyStrike() {
            this.meleeAOE(1.2, 2);
        }
        
        judgement() {
            game.enemies.forEach(e => {
                if (dist(this, e) < 150) {
                    e.stunned = 120;
                    e.takeDamage(this.atk, false, 0);
                }
            });
        }
        
        divineWrath(target) {
            setTimeout(() => {
                for (let i = 0; i < 20; i++) {
                    game.particles.push(createParticle(target.x, target.y, '#fbbf24', 10, 30));
                }
                game.enemies.forEach(e => {
                    if (dist(target, e) < 100) {
                        e.takeDamage(this.atk * 3, false, 0);
                    }
                });
            }, 400);
        }
        
        summonAngel() {
            game.summons.push({
                x: this.x + rand(-50, 50),
                y: this.y + rand(-50, 50),
                type: 'angel',
                hp: 200,
                atk: this.atk,
                duration: 600,
                owner: this
            });
        }
        
        curse(target) {
            game.enemies.forEach(e => {
                if (dist(target, e) < 100) {
                    e.cursed = 300;
                }
            });
        }
        
        summonSkeleton() {
            game.summons.push({
                x: this.x + rand(-60, 60),
                y: this.y + rand(-60, 60),
                type: 'skeleton',
                hp: 50,
                atk: this.atk * 0.5,
                duration: 900,
                owner: this
            });
        }
        
        lifeDrain() {
            game.enemies.forEach(e => {
                if (dist(this, e) < 150) {
                    const dmg = this.atk * 1.5;
                    e.takeDamage(dmg, false, 0);
                    this.hp = Math.min(this.maxHp, this.hp + dmg * 0.5);
                }
            });
        }
        
        fear() {
            game.enemies.forEach(e => {
                if (dist(this, e) < 200) {
                    e.feared = 180;
                }
            });
        }
        
        plague() {
            game.enemies.forEach(e => {
                if (dist(this, e) < 250) {
                    e.poisoned = 300;
                    e.poisonDmg = this.atk * 0.2;
                }
            });
        }
        
        roar() {
            game.enemies.forEach(e => {
                if (dist(this, e) < 200) {
                    e.feared = 120;
                }
            });
        }
        
        execute() {
            game.enemies.forEach(e => {
                if (dist(this, e) < this.range && e.hp / e.maxHp < 0.3) {
                    e.takeDamage(e.hp, true, this.angle);
                }
            });
        }
        
        summonStorm(target) {
            const storm = { x: target.x, y: target.y, radius: 120, duration: 300, dmg: this.atk * 0.5 };
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    game.enemies.forEach(e => {
                        if (dist(storm, e) < storm.radius) {
                            e.takeDamage(storm.dmg, false, 0);
                        }
                    });
                }, i * 500);
            }
        }
        
        elementalFusion() {
            // Fire + Ice + Lightning + Earth
            this.meteor({ x: this.x, y: this.y }, 200, 5);
            game.enemies.forEach(e => {
                if (dist(this, e) < 200) {
                    e.frozen = 60;
                    e.stunned = 60;
                }
            });
        }
        
        quickDraw() {
            const targets = game.enemies.filter(e => dist(this, e) < 200);
            targets.slice(0, 3).forEach(e => {
                e.takeDamage(this.atk * 2, true, this.angle);
            });
            for (let i = 0; i < 3; i++) {
                game.particles.push(createSlash(this.x, this.y, this.angle + (i - 1) * 0.3, 150, this.color));
            }
        }
        
        swordWind() {
            game.projectiles.push(createProjectile(this.x, this.y, this.angle, {
                damage: this.atk * 2, color: this.color, fromPlayer: true, type: 'wave', radius: 15, pierce: 10
            }));
        }
        
        crossSlash() {
            for (let i = 0; i < 4; i++) {
                const a = this.angle + (i * Math.PI / 2);
                game.particles.push(createSlash(this.x, this.y, a, 150, this.color));
            }
            game.enemies.forEach(e => {
                if (dist(this, e) < 150) {
                    e.takeDamage(this.atk * 3, true, this.angle);
                }
            });
        }
        
        thousandCuts() {
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const nearest = game.enemies.reduce((b, e) => (!b || dist(this, e) < dist(this, b)) ? e : b, null);
                    if (nearest && dist(this, nearest) < 200) {
                        nearest.takeDamage(this.atk * 0.5, Math.random() < 0.3, this.angle);
                        game.particles.push(createSlash(nearest.x, nearest.y, rand(0, Math.PI * 2), 40, this.color));
                    }
                }, i * 30);
            }
        }
        
        takeDamage(amount) {
            if (this.invincible > 0 || this.isDashing) return;
            
            // Counter stance
            if (this.counterStance) {
                game.enemies.forEach(e => {
                    if (dist(this, e) < 100) {
                        e.takeDamage(amount * 2, true, this.angle);
                    }
                });
                return;
            }
            
            // Shield absorb
            if (this.shield > 0) {
                this.shield -= amount;
                if (this.shield < 0) {
                    amount = -this.shield;
                    this.shield = 0;
                } else {
                    return;
                }
            }
            
            const dmg = Math.max(1, amount - this.def);
            this.hp -= dmg;
            this.invincible = 30;
            
            game.camera.shake = 8;
            spawnFloatingText(this.x, this.y, `-${dmg}`, '#ef4444');
            
            for (let i = 0; i < 10; i++) {
                game.particles.push(createParticle(this.x, this.y, '#ef4444', 5, 20));
            }
            
            if (this.hp <= 0) {
                if (this.hasResurrect) {
                    this.hp = this.maxHp * 0.5;
                    this.hasResurrect = false;
                    this.buffs = this.buffs.filter(b => b.type !== 'resurrect');
                    spawnFloatingText(this.x, this.y, '부활!', '#fbbf24', 28);
                } else {
                    gameOver();
                }
            }
        }
        
        gainExp(amount) {
            this.exp += amount;
            while (this.exp >= this.nextExp) {
                this.levelUp();
            }
        }
        
        levelUp() {
            this.level++;
            this.exp -= this.nextExp;
            this.nextExp = Math.floor(this.nextExp * 1.3);
            this.hp = this.maxHp;
            this.mp = this.maxMp;
            
            audio.play('levelup');
            for (let i = 0; i < 30; i++) {
                game.particles.push(createParticle(this.x, this.y, '#fbbf24', 8, 40));
            }
            
            showLevelUpModal();
        }
        
        draw() {
            const { x, y, radius, color, angle, invisible } = this;
            const cx = x - game.camera.x;
            const cy = y - game.camera.y;
            
            if (invisible) ctx.globalAlpha = 0.3;
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(cx, cy + 12, radius, radius * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Invincibility flash
            if (this.invincible > 0 && Math.floor(Date.now() / 80) % 2) {
                ctx.globalAlpha = 0.4;
            }
            
            // Shield visual
            if (this.shield > 0) {
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(cx, cy, radius + 10, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Body
            const grad = ctx.createRadialGradient(cx, cy - 3, 0, cx, cy, radius);
            grad.addColorStop(0, '#fff');
            grad.addColorStop(0.5, color);
            grad.addColorStop(1, color);
            
            ctx.fillStyle = grad;
            ctx.shadowColor = color;
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Direction indicator
            ctx.fillStyle = '#fff';
            const eyeX = cx + Math.cos(angle) * 8;
            const eyeY = cy + Math.sin(angle) * 8;
            ctx.beginPath();
            ctx.arc(eyeX, eyeY, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.globalAlpha = 1;
        }
    }

    // ============= ENEMY CLASS =============
    class Enemy {
        constructor(x, y, type, wave) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.angle = 0;
            
            const scale = 1 + wave * 0.05; // Reduced scaling
            
            const types = {
                slime: { radius: 15, color: '#22c55e', speed: 1.8, hp: 30, atk: 8, exp: 15, gold: 3 },
                goblin: { radius: 14, color: '#fbbf24', speed: 2.2, hp: 25, atk: 10, exp: 20, gold: 5 },
                skeleton: { radius: 16, color: '#e5e5e5', speed: 2, hp: 40, atk: 12, exp: 25, gold: 6 },
                demon: { radius: 18, color: '#dc2626', speed: 2.5, hp: 50, atk: 15, exp: 35, gold: 10 },
                ghost: { radius: 14, color: '#a855f7', speed: 3, hp: 20, atk: 8, exp: 30, gold: 8 },
                orc: { radius: 20, color: '#65a30d', speed: 1.5, hp: 80, atk: 18, exp: 40, gold: 12 },
                vampire: { radius: 16, color: '#be123c', speed: 2.8, hp: 45, atk: 14, exp: 45, gold: 15 },
                boss_dragon: { radius: 40, color: '#ef4444', speed: 1.5, hp: 300, atk: 20, exp: 200, gold: 100, isBoss: true, name: '불의 드래곤' },
                boss_lich: { radius: 35, color: '#a855f7', speed: 1.8, hp: 250, atk: 18, exp: 250, gold: 120, isBoss: true, name: '리치 왕' },
                boss_titan: { radius: 50, color: '#3b82f6', speed: 1.2, hp: 500, atk: 25, exp: 350, gold: 150, isBoss: true, name: '고대 타이탄' }
            };
            
            const t = types[type] || types.slime;
            this.radius = t.radius;
            this.color = t.color;
            this.speed = t.speed;
            this.maxHp = Math.floor(t.hp * scale);
            this.hp = this.maxHp;
            this.atk = Math.floor(t.atk * scale);
            this.exp = Math.floor(t.exp * scale);
            this.gold = Math.floor(t.gold * scale);
            this.isBoss = t.isBoss || false;
            this.name = t.name || type;
            
            this.vx = 0;
            this.vy = 0;
            this.flash = 0;
            this.stunned = 0;
            this.frozen = 0;
            this.feared = 0;
            this.poisoned = 0;
            this.poisonDmg = 0;
            this.cursed = 0;
            this.attackCooldown = 0;
            this.phase = 1;
        }
        
        update() {
            // Status effects
            if (this.stunned > 0) { this.stunned--; return; }
            if (this.frozen > 0) { this.frozen--; return; }
            
            if (this.poisoned > 0) {
                this.poisoned--;
                if (game.tick % 30 === 0) {
                    this.takeDamage(this.poisonDmg, false, 0);
                }
            }
            
            if (this.cursed > 0) {
                this.cursed--;
                if (game.tick % 60 === 0) {
                    this.takeDamage(5, false, 0);
                }
            }
            
            const p = game.player;
            const d = dist(this, p);
            this.angle = Math.atan2(p.y - this.y, p.x - this.x);
            
            // Movement
            let moveAngle = this.angle;
            if (this.feared > 0) {
                this.feared--;
                moveAngle += Math.PI;
            }
            
            // Trap check
            let speedMult = 1;
            game.traps.forEach(trap => {
                if (dist(this, trap) < trap.radius) {
                    speedMult = trap.slow;
                }
            });
            
            if (d > this.radius + p.radius) {
                this.x += Math.cos(moveAngle) * this.speed * speedMult;
                this.y += Math.sin(moveAngle) * this.speed * speedMult;
            }
            
            // Apply velocity (knockback)
            this.x += this.vx;
            this.y += this.vy;
            this.vx *= 0.85;
            this.vy *= 0.85;
            
            // Collision with player
            if (d < this.radius + p.radius && !p.invisible) {
                p.takeDamage(this.atk);
            }
            
            // Separation
            game.enemies.forEach(other => {
                if (other === this) return;
                const od = dist(this, other);
                const minD = this.radius + other.radius;
                if (od < minD && od > 0) {
                    const a = Math.atan2(this.y - other.y, this.x - other.x);
                    const push = (minD - od) * 0.3;
                    this.x += Math.cos(a) * push;
                    this.y += Math.sin(a) * push;
                }
            });
            
            this.x = clamp(this.x, this.radius, WORLD_W - this.radius);
            this.y = clamp(this.y, this.radius, WORLD_H - this.radius);
            
            // Boss patterns
            if (this.isBoss) this.bossAI();
        }
        
        bossAI() {
            this.attackCooldown--;
            
            if (this.attackCooldown <= 0) {
                this.attackCooldown = 150; // Slower attacks
                const p = game.player;
                
                if (this.type === 'boss_dragon') {
                    // Fire breath
                    for (let i = -2; i <= 2; i++) {
                        const a = this.angle + i * 0.15;
                        game.projectiles.push(createProjectile(this.x, this.y, a, {
                            damage: this.atk * 0.5, color: '#f97316', fromPlayer: false, type: 'fireball'
                        }));
                    }
                } else if (this.type === 'boss_lich') {
                    // Summon 2 skeletons
                    for (let i = 0; i < 2; i++) {
                        const a = Math.random() * Math.PI * 2;
                        game.enemies.push(new Enemy(
                            this.x + Math.cos(a) * 60,
                            this.y + Math.sin(a) * 60,
                            'skeleton', game.wave
                        ));
                    }
                } else if (this.type === 'boss_titan') {
                    // Ground slam warning
                    setTimeout(() => {
                        if (dist(this, p) < 120) {
                            p.takeDamage(this.atk);
                        }
                        game.camera.shake = 10;
                    }, 600);
                }
            }
            
            // Phase 2 at 50% HP
            if (this.hp < this.maxHp * 0.5 && this.phase === 1) {
                this.phase = 2;
                this.speed *= 1.2;
            }
        }
        
        takeDamage(amount, isCrit, fromAngle) {
            this.hp -= amount;
            this.flash = 10;
            
            // Enhanced floating text
            const textSize = isCrit ? 28 : 18;
            const textColor = isCrit ? '#ffd700' : '#fff';
            spawnFloatingText(this.x, this.y - this.radius, isCrit ? `${amount}!` : amount, textColor, textSize);
            
            // Knockback
            const kb = this.isBoss ? 3 : 8;
            this.vx += Math.cos(fromAngle) * kb;
            this.vy += Math.sin(fromAngle) * kb;
            
            // Enhanced hit effects
            const hitParticles = createHitEffect(this.x, this.y, this.color, fromAngle, isCrit);
            hitParticles.forEach(p => game.particles.push(p));
            
            // Blood/damage splatter
            for (let i = 0; i < (isCrit ? 12 : 6); i++) {
                const a = fromAngle + rand(-0.6, 0.6);
                const speed = rand(2, 6);
                game.particles.push(createParticle(this.x, this.y, this.color, rand(3, 7), rand(20, 35), {
                    vx: Math.cos(a) * speed,
                    vy: Math.sin(a) * speed,
                    gravity: 0.15,
                    friction: 0.95
                }));
            }
            
            // Sound effects
            if (isCrit) {
                audio.play('critical');
                game.camera.shake = 12;
            } else {
                audio.play('hit', { intensity: 0.8 });
                game.camera.shake = 6;
            }
            
            if (this.hp <= 0) this.die();
        }
        
        die() {
            const p = game.player;
            p.kills++;
            p.gainExp(this.exp);
            p.gold += this.gold;
            
            // Check stage progress
            checkStageProgress();
            
            // Check if stage boss defeated
            if (this.isStageBoss) {
                advanceToNextStage();
            }
            
            // Soul harvest passive
            if (p.passive.effect === 'soulHarvest') {
                p.hp = Math.min(p.maxHp, p.hp + p.maxHp * 0.05);
            }
            
            // Drop loot
            if (Math.random() < 0.25) {
                game.loot.push({ x: this.x, y: this.y, type: 'health', value: 20 });
            }
            if (Math.random() < 0.15) {
                game.loot.push({ x: this.x, y: this.y, type: 'mana', value: 15 });
            }
            
            // Enhanced death effects
            const count = this.isBoss ? 60 : 20;
            
            // Explosion particles
            const explosionParticles = createExplosion(this.x, this.y, this.color, count, {
                power: this.isBoss ? 2 : 1,
                gravity: 0.1
            });
            explosionParticles.forEach(ep => game.particles.push(ep));
            
            // Spark burst
            const sparks = createSparkBurst(this.x, this.y, this.color, this.isBoss ? 30 : 15);
            sparks.forEach(sp => game.particles.push(sp));
            
            // Ring shockwave
            game.particles.push(createRingEffect(this.x, this.y, this.color, this.isBoss ? 150 : 80));
            
            // Secondary ring for bosses
            if (this.isBoss) {
                setTimeout(() => {
                    game.particles.push(createRingEffect(this.x, this.y, '#fff', 200));
                }, 100);
                
                // Victory particles
                for (let i = 0; i < 30; i++) {
                    setTimeout(() => {
                        game.particles.push(createParticle(
                            this.x + rand(-100, 100),
                            this.y + rand(-100, 100),
                            ['#ffd700', '#ff6347', '#00ff7f', '#ff69b4', '#00bfff'][randInt(0, 4)],
                            rand(5, 12), rand(40, 60), {
                                vx: rand(-2, 2),
                                vy: rand(-4, -1),
                                type: 'star',
                                spin: rand(-0.1, 0.1),
                                gravity: 0.05
                            }
                        ));
                    }, i * 30);
                }
                
                spawnFloatingText(this.x, this.y - 50, 'BOSS DEFEATED!', '#ffd700', 32);
            }
            
            audio.play('explosion', { size: this.isBoss ? 2 : 1 });
            game.camera.shake = this.isBoss ? 25 : 8;
            
            const idx = game.enemies.indexOf(this);
            if (idx > -1) game.enemies.splice(idx, 1);
        }
        
        draw() {
            const cx = this.x - game.camera.x;
            const cy = this.y - game.camera.y;
            const r = this.radius;
            const time = Date.now() / 1000;
            
            // Status effects auras
            if (this.frozen > 0) {
                ctx.fillStyle = 'rgba(6, 182, 212, 0.3)';
                ctx.beginPath();
                ctx.arc(cx, cy, r + 8, 0, Math.PI * 2);
                ctx.fill();
                // Ice crystals
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    const a = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(cx + Math.cos(a) * (r + 5), cy + Math.sin(a) * (r + 5));
                    ctx.lineTo(cx + Math.cos(a) * (r + 12), cy + Math.sin(a) * (r + 12));
                    ctx.stroke();
                }
            }
            
            if (this.poisoned > 0) {
                ctx.strokeStyle = '#84cc16';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(cx, cy, r + 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                // Poison bubbles
                for (let i = 0; i < 3; i++) {
                    const bubbleY = cy - r - 5 - ((time * 20 + i * 10) % 20);
                    ctx.fillStyle = '#84cc16';
                    ctx.beginPath();
                    ctx.arc(cx + (i - 1) * 8, bubbleY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            if (this.cursed > 0) {
                ctx.strokeStyle = '#8b5cf6';
                ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    const a = time * 2 + (i / 4) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(cx + Math.cos(a) * (r + 8), cy + Math.sin(a) * (r + 8), 4, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(cx, cy + r * 0.8, r * 0.8, r * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            const isFlashing = this.flash > 0;
            if (isFlashing) this.flash--;
            
            ctx.save();
            ctx.translate(cx, cy);
            
            // Draw based on enemy type
            switch(this.type) {
                case 'slime':
                    this.drawSlime(r, isFlashing, time);
                    break;
                case 'goblin':
                    this.drawGoblin(r, isFlashing, time);
                    break;
                case 'skeleton':
                    this.drawSkeleton(r, isFlashing, time);
                    break;
                case 'demon':
                    this.drawDemon(r, isFlashing, time);
                    break;
                case 'ghost':
                    this.drawGhost(r, isFlashing, time);
                    break;
                case 'orc':
                    this.drawOrc(r, isFlashing, time);
                    break;
                case 'vampire':
                    this.drawVampire(r, isFlashing, time);
                    break;
                case 'boss_dragon':
                    this.drawDragon(r, isFlashing, time);
                    break;
                case 'boss_lich':
                    this.drawLich(r, isFlashing, time);
                    break;
                case 'boss_titan':
                    this.drawTitan(r, isFlashing, time);
                    break;
                default:
                    this.drawDefault(r, isFlashing);
            }
            
            ctx.restore();
            
            // HP bar for non-boss enemies (only when damaged)
            if (!this.isBoss && this.hp < this.maxHp) {
                const barWidth = r * 2;
                const barHeight = 4;
                const barY = -r - 10;
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(cx - barWidth/2, cy + barY, barWidth, barHeight);
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(cx - barWidth/2, cy + barY, barWidth * (this.hp / this.maxHp), barHeight);
            }
            
            // Boss HP UI
            if (this.isBoss) {
                document.getElementById('boss-hp-container').style.display = 'block';
                document.getElementById('boss-name').textContent = this.name;
                document.getElementById('boss-hp-text').textContent = `${Math.ceil(this.hp)} / ${this.maxHp}`;
                document.getElementById('boss-hp-fill').style.width = `${(this.hp / this.maxHp) * 100}%`;
            }
        }
        
        drawDefault(r, flash) {
            ctx.fillStyle = flash ? '#fff' : this.color;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        drawSlime(r, flash, time) {
            const wobble = Math.sin(time * 5) * 2;
            const squish = 1 + Math.sin(time * 3) * 0.1;
            
            // Body - jelly-like
            const grad = ctx.createRadialGradient(0, -r * 0.3, 0, 0, 0, r);
            grad.addColorStop(0, flash ? '#fff' : '#4ade80');
            grad.addColorStop(0.5, flash ? '#fff' : '#22c55e');
            grad.addColorStop(1, flash ? '#fff' : '#15803d');
            
            ctx.fillStyle = grad;
            ctx.shadowColor = '#22c55e';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.ellipse(0, wobble, r * squish, r / squish, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Shine highlight
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.ellipse(-r * 0.3, -r * 0.3 + wobble, r * 0.25, r * 0.15, -0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Simple cute black eyes (small dots)
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.arc(-r * 0.2, 0 + wobble, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.2, 0 + wobble, 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Simple cute smile
            ctx.strokeStyle = '#15803d';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, r * 0.15 + wobble, r * 0.18, 0.2, Math.PI - 0.2);
            ctx.stroke();
        }
        
        drawGoblin(r, flash, time) {
            const bodyColor = flash ? '#fff' : '#65a30d';
            const darkColor = flash ? '#ddd' : '#3f6212';
            
            // Body
            ctx.fillStyle = bodyColor;
            ctx.shadowColor = '#65a30d';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.ellipse(0, 2, r * 0.9, r, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Ears (pointy)
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.moveTo(-r * 0.7, -r * 0.3);
            ctx.lineTo(-r * 1.2, -r * 0.8);
            ctx.lineTo(-r * 0.5, -r * 0.1);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.7, -r * 0.3);
            ctx.lineTo(r * 1.2, -r * 0.8);
            ctx.lineTo(r * 0.5, -r * 0.1);
            ctx.fill();
            
            // Face
            ctx.fillStyle = darkColor;
            ctx.beginPath();
            ctx.arc(0, -r * 0.1, r * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes (angry)
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.arc(-r * 0.25, -r * 0.2, 5, 0, Math.PI * 2);
            ctx.arc(r * 0.25, -r * 0.2, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-r * 0.25, -r * 0.2, 2, 0, Math.PI * 2);
            ctx.arc(r * 0.25, -r * 0.2, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Angry eyebrows
            ctx.strokeStyle = darkColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-r * 0.45, -r * 0.4);
            ctx.lineTo(-r * 0.1, -r * 0.35);
            ctx.moveTo(r * 0.45, -r * 0.4);
            ctx.lineTo(r * 0.1, -r * 0.35);
            ctx.stroke();
            
            // Nose
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.arc(0, r * 0.05, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Teeth
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(-r * 0.15, r * 0.25);
            ctx.lineTo(-r * 0.1, r * 0.4);
            ctx.lineTo(-r * 0.05, r * 0.25);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.15, r * 0.25);
            ctx.lineTo(r * 0.1, r * 0.4);
            ctx.lineTo(r * 0.05, r * 0.25);
            ctx.fill();
        }
        
        drawSkeleton(r, flash, time) {
            const boneColor = flash ? '#fff' : '#e5e5e5';
            const darkColor = flash ? '#ccc' : '#a3a3a3';
            
            // Skull
            ctx.fillStyle = boneColor;
            ctx.shadowColor = '#e5e5e5';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(0, -r * 0.1, r * 0.85, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Jaw
            ctx.fillStyle = boneColor;
            ctx.beginPath();
            ctx.moveTo(-r * 0.5, r * 0.2);
            ctx.quadraticCurveTo(-r * 0.6, r * 0.7, 0, r * 0.8);
            ctx.quadraticCurveTo(r * 0.6, r * 0.7, r * 0.5, r * 0.2);
            ctx.fill();
            
            // Eye sockets
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(-r * 0.3, -r * 0.15, r * 0.22, r * 0.28, 0, 0, Math.PI * 2);
            ctx.ellipse(r * 0.3, -r * 0.15, r * 0.22, r * 0.28, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Glowing eyes
            ctx.fillStyle = '#ef4444';
            ctx.shadowColor = '#ef4444';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(-r * 0.3, -r * 0.15, 4, 0, Math.PI * 2);
            ctx.arc(r * 0.3, -r * 0.15, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Nose hole
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.moveTo(0, r * 0.05);
            ctx.lineTo(-r * 0.1, r * 0.25);
            ctx.lineTo(r * 0.1, r * 0.25);
            ctx.fill();
            
            // Teeth
            ctx.fillStyle = boneColor;
            ctx.strokeStyle = darkColor;
            ctx.lineWidth = 1;
            for (let i = -3; i <= 3; i++) {
                ctx.beginPath();
                ctx.rect(i * r * 0.12 - r * 0.05, r * 0.35, r * 0.1, r * 0.15);
                ctx.fill();
                ctx.stroke();
            }
            
            // Cracks
            ctx.strokeStyle = darkColor;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-r * 0.5, -r * 0.5);
            ctx.lineTo(-r * 0.3, -r * 0.3);
            ctx.lineTo(-r * 0.4, -r * 0.1);
            ctx.stroke();
        }
        
        drawDemon(r, flash, time) {
            const bodyColor = flash ? '#fff' : '#dc2626';
            const darkColor = flash ? '#ddd' : '#991b1b';
            
            // Wings
            ctx.fillStyle = darkColor;
            ctx.beginPath();
            ctx.moveTo(-r * 0.5, 0);
            ctx.quadraticCurveTo(-r * 1.5, -r * 0.5, -r * 1.3, r * 0.3);
            ctx.quadraticCurveTo(-r * 1.0, 0, -r * 0.5, r * 0.2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.5, 0);
            ctx.quadraticCurveTo(r * 1.5, -r * 0.5, r * 1.3, r * 0.3);
            ctx.quadraticCurveTo(r * 1.0, 0, r * 0.5, r * 0.2);
            ctx.fill();
            
            // Body
            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
            grad.addColorStop(0, flash ? '#fff' : '#f87171');
            grad.addColorStop(1, bodyColor);
            ctx.fillStyle = grad;
            ctx.shadowColor = '#dc2626';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Horns
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.moveTo(-r * 0.5, -r * 0.7);
            ctx.quadraticCurveTo(-r * 0.8, -r * 1.5, -r * 0.3, -r * 1.3);
            ctx.lineTo(-r * 0.4, -r * 0.7);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.5, -r * 0.7);
            ctx.quadraticCurveTo(r * 0.8, -r * 1.5, r * 0.3, -r * 1.3);
            ctx.lineTo(r * 0.4, -r * 0.7);
            ctx.fill();
            
            // Eyes (glowing)
            ctx.fillStyle = '#fbbf24';
            ctx.shadowColor = '#fbbf24';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.ellipse(-r * 0.3, -r * 0.1, 6, 4, 0, 0, Math.PI * 2);
            ctx.ellipse(r * 0.3, -r * 0.1, 6, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Evil smile
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, r * 0.1, r * 0.4, 0.3, Math.PI - 0.3);
            ctx.stroke();
            
            // Fangs
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(-r * 0.3, r * 0.3);
            ctx.lineTo(-r * 0.25, r * 0.5);
            ctx.lineTo(-r * 0.2, r * 0.3);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.3, r * 0.3);
            ctx.lineTo(r * 0.25, r * 0.5);
            ctx.lineTo(r * 0.2, r * 0.3);
            ctx.fill();
        }
        
        drawGhost(r, flash, time) {
            const float = Math.sin(time * 3) * 5;
            const alpha = 0.7 + Math.sin(time * 2) * 0.2;
            
            ctx.globalAlpha = alpha;
            
            // Body
            const grad = ctx.createRadialGradient(0, -r * 0.3 + float, 0, 0, float, r * 1.2);
            grad.addColorStop(0, flash ? '#fff' : '#e9d5ff');
            grad.addColorStop(0.5, flash ? '#fff' : '#a855f7');
            grad.addColorStop(1, flash ? '#fff' : '#7c3aed');
            
            ctx.fillStyle = grad;
            ctx.shadowColor = '#a855f7';
            ctx.shadowBlur = 20;
            
            ctx.beginPath();
            ctx.moveTo(-r, float);
            ctx.quadraticCurveTo(-r, -r + float, 0, -r + float);
            ctx.quadraticCurveTo(r, -r + float, r, float);
            // Wavy bottom
            ctx.quadraticCurveTo(r * 0.7, r * 0.8 + float, r * 0.5, r + float);
            ctx.quadraticCurveTo(r * 0.25, r * 0.7 + float, 0, r + float);
            ctx.quadraticCurveTo(-r * 0.25, r * 0.7 + float, -r * 0.5, r + float);
            ctx.quadraticCurveTo(-r * 0.7, r * 0.8 + float, -r, float);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Eyes
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(-r * 0.3, -r * 0.2 + float, r * 0.2, r * 0.25, 0, 0, Math.PI * 2);
            ctx.ellipse(r * 0.3, -r * 0.2 + float, r * 0.2, r * 0.25, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Mouth (O shape)
            ctx.beginPath();
            ctx.ellipse(0, r * 0.3 + float, r * 0.2, r * 0.25, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.globalAlpha = 1;
        }
        
        drawOrc(r, flash, time) {
            const bodyColor = flash ? '#fff' : '#4d7c0f';
            const darkColor = flash ? '#ddd' : '#365314';
            
            // Body (muscular)
            ctx.fillStyle = bodyColor;
            ctx.shadowColor = '#4d7c0f';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.ellipse(0, 0, r, r * 1.1, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Ears
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.ellipse(-r * 0.9, -r * 0.2, r * 0.25, r * 0.4, -0.3, 0, Math.PI * 2);
            ctx.ellipse(r * 0.9, -r * 0.2, r * 0.25, r * 0.4, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Face detail
            ctx.fillStyle = darkColor;
            ctx.beginPath();
            ctx.arc(0, r * 0.1, r * 0.5, 0, Math.PI);
            ctx.fill();
            
            // Eyes (small, angry)
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.arc(-r * 0.3, -r * 0.2, 5, 0, Math.PI * 2);
            ctx.arc(r * 0.3, -r * 0.2, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-r * 0.3, -r * 0.2, 2, 0, Math.PI * 2);
            ctx.arc(r * 0.3, -r * 0.2, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Brow ridge
            ctx.fillStyle = darkColor;
            ctx.beginPath();
            ctx.ellipse(0, -r * 0.35, r * 0.6, r * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Tusks
            ctx.fillStyle = '#f5f5f4';
            ctx.beginPath();
            ctx.moveTo(-r * 0.4, r * 0.3);
            ctx.quadraticCurveTo(-r * 0.5, r * 0.1, -r * 0.35, -r * 0.1);
            ctx.lineTo(-r * 0.25, r * 0.25);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.4, r * 0.3);
            ctx.quadraticCurveTo(r * 0.5, r * 0.1, r * 0.35, -r * 0.1);
            ctx.lineTo(r * 0.25, r * 0.25);
            ctx.fill();
            
            // War paint
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-r * 0.6, -r * 0.5);
            ctx.lineTo(-r * 0.3, -r * 0.3);
            ctx.moveTo(r * 0.6, -r * 0.5);
            ctx.lineTo(r * 0.3, -r * 0.3);
            ctx.stroke();
        }
        
        drawVampire(r, flash, time) {
            const skinColor = flash ? '#fff' : '#e5e5e5';
            const capeColor = flash ? '#ddd' : '#7f1d1d';
            
            // Cape
            ctx.fillStyle = capeColor;
            ctx.beginPath();
            ctx.moveTo(-r * 0.3, -r * 0.5);
            ctx.quadraticCurveTo(-r * 1.3, 0, -r * 1.1, r * 1.2);
            ctx.lineTo(0, r * 0.8);
            ctx.lineTo(r * 1.1, r * 1.2);
            ctx.quadraticCurveTo(r * 1.3, 0, r * 0.3, -r * 0.5);
            ctx.fill();
            
            // Cape collar
            ctx.beginPath();
            ctx.moveTo(-r * 0.4, -r * 0.3);
            ctx.lineTo(-r * 0.7, -r * 0.8);
            ctx.lineTo(0, -r * 0.4);
            ctx.lineTo(r * 0.7, -r * 0.8);
            ctx.lineTo(r * 0.4, -r * 0.3);
            ctx.fill();
            
            // Face
            ctx.fillStyle = skinColor;
            ctx.shadowColor = '#a855f7';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.ellipse(0, -r * 0.1, r * 0.6, r * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Hair
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(0, -r * 0.5, r * 0.55, r * 0.35, 0, Math.PI, Math.PI * 2);
            ctx.fill();
            // Widow's peak
            ctx.beginPath();
            ctx.moveTo(-r * 0.3, -r * 0.5);
            ctx.lineTo(0, -r * 0.2);
            ctx.lineTo(r * 0.3, -r * 0.5);
            ctx.fill();
            
            // Eyes (red, glowing)
            ctx.fillStyle = '#dc2626';
            ctx.shadowColor = '#dc2626';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.ellipse(-r * 0.25, -r * 0.15, 5, 4, 0, 0, Math.PI * 2);
            ctx.ellipse(r * 0.25, -r * 0.15, 5, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Fangs
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(-r * 0.15, r * 0.2);
            ctx.lineTo(-r * 0.1, r * 0.45);
            ctx.lineTo(-r * 0.05, r * 0.2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.15, r * 0.2);
            ctx.lineTo(r * 0.1, r * 0.45);
            ctx.lineTo(r * 0.05, r * 0.2);
            ctx.fill();
        }
        
        drawDragon(r, flash, time) {
            const scale = flash ? '#fff' : '#dc2626';
            const darkScale = flash ? '#ddd' : '#991b1b';
            const belly = flash ? '#eee' : '#fbbf24';
            
            // Wings
            ctx.fillStyle = darkScale;
            for (let side = -1; side <= 1; side += 2) {
                ctx.beginPath();
                ctx.moveTo(side * r * 0.5, -r * 0.2);
                ctx.quadraticCurveTo(side * r * 1.8, -r * 1.5, side * r * 2, -r * 0.3);
                ctx.lineTo(side * r * 1.5, r * 0.2);
                ctx.quadraticCurveTo(side * r * 1.2, -r * 0.5, side * r * 0.5, 0);
                ctx.fill();
                // Wing bones
                ctx.strokeStyle = scale;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(side * r * 0.5, -r * 0.1);
                ctx.lineTo(side * r * 1.8, -r * 1.2);
                ctx.moveTo(side * r * 0.8, -r * 0.3);
                ctx.lineTo(side * r * 1.5, -r * 0.8);
                ctx.stroke();
            }
            
            // Body
            const grad = ctx.createRadialGradient(0, 0, r * 0.3, 0, 0, r);
            grad.addColorStop(0, belly);
            grad.addColorStop(0.4, scale);
            grad.addColorStop(1, darkScale);
            ctx.fillStyle = grad;
            ctx.shadowColor = '#ef4444';
            ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.ellipse(0, 0, r, r * 0.9, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Scales pattern
            ctx.strokeStyle = darkScale;
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.arc(0, -r * 0.3 + i * r * 0.25, r * (0.6 - i * 0.08), 0.5, Math.PI - 0.5);
                ctx.stroke();
            }
            
            // Horns
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.moveTo(-r * 0.4, -r * 0.7);
            ctx.quadraticCurveTo(-r * 0.6, -r * 1.4, -r * 0.2, -r * 1.2);
            ctx.lineTo(-r * 0.3, -r * 0.7);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.4, -r * 0.7);
            ctx.quadraticCurveTo(r * 0.6, -r * 1.4, r * 0.2, -r * 1.2);
            ctx.lineTo(r * 0.3, -r * 0.7);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = '#fbbf24';
            ctx.shadowColor = '#fbbf24';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.ellipse(-r * 0.3, -r * 0.25, 8, 6, 0, 0, Math.PI * 2);
            ctx.ellipse(r * 0.3, -r * 0.25, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(-r * 0.3, -r * 0.25, 3, 5, 0, 0, Math.PI * 2);
            ctx.ellipse(r * 0.3, -r * 0.25, 3, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Snout
            ctx.fillStyle = scale;
            ctx.beginPath();
            ctx.ellipse(0, r * 0.2, r * 0.35, r * 0.25, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Nostrils with fire
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(-r * 0.12, r * 0.15, 4, 3, 0, 0, Math.PI * 2);
            ctx.ellipse(r * 0.12, r * 0.15, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Fire breath particles
            if (Math.random() > 0.7) {
                ctx.fillStyle = '#f97316';
                ctx.beginPath();
                ctx.arc(rand(-5, 5), r * 0.4 + rand(0, 10), rand(3, 6), 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        drawLich(r, flash, time) {
            const robeColor = flash ? '#ddd' : '#581c87';
            const boneColor = flash ? '#fff' : '#e5e5e5';
            
            // Dark aura
            ctx.fillStyle = 'rgba(147, 51, 234, 0.3)';
            ctx.beginPath();
            ctx.arc(0, 0, r * 1.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Floating particles
            for (let i = 0; i < 5; i++) {
                const angle = time * 2 + (i / 5) * Math.PI * 2;
                const dist = r * 1.1;
                ctx.fillStyle = '#a855f7';
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Robe
            ctx.fillStyle = robeColor;
            ctx.beginPath();
            ctx.moveTo(-r * 0.6, -r * 0.3);
            ctx.quadraticCurveTo(-r * 0.8, r * 0.5, -r * 0.5, r);
            ctx.lineTo(r * 0.5, r);
            ctx.quadraticCurveTo(r * 0.8, r * 0.5, r * 0.6, -r * 0.3);
            ctx.quadraticCurveTo(0, -r * 0.5, -r * 0.6, -r * 0.3);
            ctx.fill();
            
            // Hood
            ctx.fillStyle = robeColor;
            ctx.beginPath();
            ctx.ellipse(0, -r * 0.2, r * 0.7, r * 0.6, 0, Math.PI, Math.PI * 2);
            ctx.fill();
            
            // Skull face
            ctx.fillStyle = boneColor;
            ctx.beginPath();
            ctx.ellipse(0, -r * 0.1, r * 0.45, r * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye sockets with magic
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(-r * 0.2, -r * 0.2, r * 0.15, r * 0.18, 0, 0, Math.PI * 2);
            ctx.ellipse(r * 0.2, -r * 0.2, r * 0.15, r * 0.18, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Glowing eyes
            ctx.fillStyle = '#22d3ee';
            ctx.shadowColor = '#22d3ee';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(-r * 0.2, -r * 0.2, 5, 0, Math.PI * 2);
            ctx.arc(r * 0.2, -r * 0.2, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Staff
            ctx.strokeStyle = '#713f12';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(r * 0.8, -r * 0.8);
            ctx.lineTo(r * 0.5, r);
            ctx.stroke();
            
            // Staff orb
            ctx.fillStyle = '#22d3ee';
            ctx.shadowColor = '#22d3ee';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(r * 0.8, -r * 0.9, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        drawTitan(r, flash, time) {
            const stoneColor = flash ? '#fff' : '#64748b';
            const darkStone = flash ? '#ddd' : '#475569';
            const glowColor = '#3b82f6';
            
            // Body (massive stone golem)
            const grad = ctx.createRadialGradient(0, 0, r * 0.3, 0, 0, r);
            grad.addColorStop(0, flash ? '#fff' : '#94a3b8');
            grad.addColorStop(0.7, stoneColor);
            grad.addColorStop(1, darkStone);
            
            ctx.fillStyle = grad;
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Stone cracks with glow
            ctx.strokeStyle = glowColor;
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 10;
            ctx.lineWidth = 2;
            
            // Crack patterns
            ctx.beginPath();
            ctx.moveTo(-r * 0.6, -r * 0.4);
            ctx.lineTo(-r * 0.3, -r * 0.1);
            ctx.lineTo(-r * 0.5, r * 0.3);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(r * 0.5, -r * 0.5);
            ctx.lineTo(r * 0.2, -r * 0.2);
            ctx.lineTo(r * 0.4, r * 0.2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, -r * 0.7);
            ctx.lineTo(-r * 0.1, -r * 0.4);
            ctx.lineTo(r * 0.1, -r * 0.2);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Ancient runes
            ctx.strokeStyle = glowColor;
            ctx.lineWidth = 3;
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 15;
            
            // Rune circle
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.5, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner runes
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 + time;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * r * 0.3, Math.sin(angle) * r * 0.3);
                ctx.lineTo(Math.cos(angle) * r * 0.5, Math.sin(angle) * r * 0.5);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;
            
            // Eyes (glowing blue)
            ctx.fillStyle = glowColor;
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.ellipse(-r * 0.3, -r * 0.2, 10, 6, 0, 0, Math.PI * 2);
            ctx.ellipse(r * 0.3, -r * 0.2, 10, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Mouth (grimace)
            ctx.strokeStyle = darkStone;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(-r * 0.35, r * 0.3);
            ctx.lineTo(-r * 0.2, r * 0.4);
            ctx.lineTo(0, r * 0.35);
            ctx.lineTo(r * 0.2, r * 0.4);
            ctx.lineTo(r * 0.35, r * 0.3);
            ctx.stroke();
            
            // Shoulder stones
            ctx.fillStyle = stoneColor;
            ctx.beginPath();
            ctx.ellipse(-r * 0.9, r * 0.1, r * 0.3, r * 0.25, -0.3, 0, Math.PI * 2);
            ctx.ellipse(r * 0.9, r * 0.1, r * 0.3, r * 0.25, 0.3, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // ============= HELPER FUNCTIONS =============
    function screenToWorld(sx, sy) {
        return { x: sx + game.camera.x, y: sy + game.camera.y };
    }

    function createParticle(x, y, color, size, life, opts = {}) {
        return {
            x, y, color, size, life, maxLife: life,
            vx: opts.vx !== undefined ? opts.vx : rand(-3, 3), 
            vy: opts.vy !== undefined ? opts.vy : rand(-3, 3),
            type: opts.type || 'circle',
            gravity: opts.gravity || 0,
            friction: opts.friction || 0.98,
            glow: opts.glow !== undefined ? opts.glow : true,
            trail: opts.trail || false,
            spin: opts.spin || 0,
            angle: opts.angle || 0,
            scale: opts.scale || 1,
            fadeIn: opts.fadeIn || false
        };
    }

    function createSlash(x, y, angle, range, color, opts = {}) {
        return {
            x, y, angle, range, color,
            life: opts.life || 15, 
            maxLife: opts.life || 15,
            type: 'slash',
            thickness: opts.thickness || 6,
            arc: opts.arc || 1.2,
            secondary: opts.secondary || null,
            trail: opts.trail !== undefined ? opts.trail : true
        };
    }
    
    // Enhanced particle effects
    function createExplosion(x, y, color, count = 20, opts = {}) {
        const particles = [];
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2 + rand(-0.2, 0.2);
            const speed = rand(2, 8) * (opts.power || 1);
            particles.push(createParticle(x, y, color, rand(3, 8), rand(20, 40), {
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                gravity: opts.gravity || 0.1,
                glow: true
            }));
        }
        // Center flash
        particles.push(createParticle(x, y, '#fff', 30, 8, {
            vx: 0, vy: 0, type: 'flash', glow: true
        }));
        return particles;
    }
    
    function createSparkBurst(x, y, color, count = 15) {
        const particles = [];
        for (let i = 0; i < count; i++) {
            const angle = rand(0, Math.PI * 2);
            const speed = rand(4, 12);
            particles.push(createParticle(x, y, color, rand(1, 3), rand(15, 30), {
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                type: 'spark',
                trail: true,
                friction: 0.92
            }));
        }
        return particles;
    }
    
    function createRingEffect(x, y, color, radius = 50) {
        return {
            x, y, color, radius: 0, maxRadius: radius,
            life: 20, maxLife: 20,
            type: 'ring',
            thickness: 4
        };
    }
    
    function createTrailEffect(x, y, color, angle) {
        return createParticle(x, y, color, rand(4, 8), 15, {
            vx: Math.cos(angle + Math.PI) * 2,
            vy: Math.sin(angle + Math.PI) * 2,
            type: 'trail',
            glow: true,
            friction: 0.9
        });
    }
    
    function createHitEffect(x, y, color, angle, isCrit = false) {
        const particles = [];
        const count = isCrit ? 25 : 12;
        const power = isCrit ? 1.5 : 1;
        
        // Directional sparks
        for (let i = 0; i < count; i++) {
            const a = angle + rand(-0.8, 0.8);
            const speed = rand(3, 10) * power;
            particles.push(createParticle(x, y, color, rand(2, 5), rand(15, 30), {
                vx: Math.cos(a) * speed,
                vy: Math.sin(a) * speed,
                type: 'spark',
                trail: true,
                friction: 0.9,
                gravity: 0.15
            }));
        }
        
        // Impact flash
        particles.push(createParticle(x, y, '#fff', isCrit ? 40 : 25, 6, {
            vx: 0, vy: 0, type: 'flash'
        }));
        
        // Shockwave ring
        if (isCrit) {
            game.particles.push(createRingEffect(x, y, color, 80));
            // Extra star particles for crit
            for (let i = 0; i < 5; i++) {
                particles.push(createParticle(x + rand(-20, 20), y + rand(-20, 20), '#ffd700', rand(8, 15), 30, {
                    vx: rand(-1, 1), vy: rand(-3, -1),
                    type: 'star',
                    spin: rand(-0.2, 0.2),
                    gravity: 0.05
                }));
            }
        }
        
        return particles;
    }
    
    function createMagicEffect(x, y, color, type = 'fire') {
        const particles = [];
        
        switch(type) {
            case 'fire':
                for (let i = 0; i < 20; i++) {
                    particles.push(createParticle(x + rand(-15, 15), y + rand(-15, 15), 
                        ['#ff4500', '#ff6347', '#ffa500', '#ffff00'][randInt(0, 3)], 
                        rand(5, 12), rand(20, 40), {
                        vx: rand(-2, 2),
                        vy: rand(-5, -2),
                        type: 'fire',
                        gravity: -0.1
                    }));
                }
                break;
            case 'ice':
                for (let i = 0; i < 15; i++) {
                    const angle = rand(0, Math.PI * 2);
                    particles.push(createParticle(x, y, 
                        ['#00ffff', '#87ceeb', '#b0e0e6', '#ffffff'][randInt(0, 3)], 
                        rand(3, 8), rand(25, 45), {
                        vx: Math.cos(angle) * rand(2, 5),
                        vy: Math.sin(angle) * rand(2, 5),
                        type: 'ice',
                        spin: rand(-0.1, 0.1)
                    }));
                }
                game.particles.push(createRingEffect(x, y, '#00ffff', 60));
                break;
            case 'lightning':
                for (let i = 0; i < 10; i++) {
                    particles.push(createParticle(x + rand(-30, 30), y + rand(-30, 30), 
                        '#ffff00', rand(2, 4), rand(5, 15), {
                        vx: rand(-8, 8),
                        vy: rand(-8, 8),
                        type: 'lightning',
                        trail: true
                    }));
                }
                break;
            case 'holy':
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    particles.push(createParticle(x, y, '#ffd700', rand(4, 8), 35, {
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        type: 'holy',
                        glow: true
                    }));
                }
                game.particles.push(createRingEffect(x, y, '#ffd700', 70));
                break;
            case 'dark':
                for (let i = 0; i < 15; i++) {
                    particles.push(createParticle(x + rand(-20, 20), y + rand(-20, 20), 
                        ['#4b0082', '#8b008b', '#9400d3'][randInt(0, 2)], 
                        rand(5, 10), rand(30, 50), {
                        vx: rand(-1, 1),
                        vy: rand(-2, 0),
                        type: 'dark',
                        gravity: -0.05
                    }));
                }
                break;
        }
        
        return particles;
    }

    function createProjectile(x, y, angle, opts) {
        return {
            x, y, angle,
            vx: Math.cos(angle) * (opts.speed || 12),
            vy: Math.sin(angle) * (opts.speed || 12),
            damage: opts.damage || 10,
            color: opts.color || '#fff',
            radius: opts.radius || 6,
            fromPlayer: opts.fromPlayer || false,
            life: opts.life || 150,
            type: opts.type || 'normal',
            pierce: opts.pierce || 1,
            hitList: new Set(),
            explode: opts.explode,
            freeze: opts.freeze,
            poison: opts.poison,
            slow: opts.slow
        };
    }

    function spawnFloatingText(x, y, text, color = '#fff', size = 16) {
        game.floatingTexts.push({ x, y, text: String(text), color, size, life: 60 });
    }

    // ============= TIME & WEATHER SYSTEM =============
    function updateTimeAndWeather() {
        // Time of day cycle (every 60 seconds = 1 game hour, 4 phases)
        game.dayNightCycle++;
        if (game.dayNightCycle >= 900) { // 15 seconds per phase
            game.dayNightCycle = 0;
            const phases = ['dawn', 'day', 'dusk', 'night'];
            const currentIndex = phases.indexOf(game.timeOfDay);
            game.timeOfDay = phases[(currentIndex + 1) % 4];
            updateTimeWeatherUI();
        }
        
        // Weather changes
        game.weatherTimer++;
        if (game.weatherTimer >= 1800) { // 30 seconds
            game.weatherTimer = 0;
            const stage = STAGES[game.currentStage];
            const weathers = stage.id === 'snow' ? ['snow', 'clear', 'fog'] :
                           stage.id === 'volcano' ? ['clear', 'fog'] :
                           stage.id === 'desert' ? ['clear', 'storm'] :
                           ['clear', 'rain', 'fog'];
            game.weather = weathers[randInt(0, weathers.length - 1)];
            updateTimeWeatherUI();
            updateWeatherEffects();
        }
    }
    
    function updateTimeWeatherUI() {
        const time = TIME_PHASES[game.timeOfDay];
        const weather = WEATHER_TYPES[game.weather];
        document.getElementById('time-weather').textContent = `${time.icon} ${time.name} | ${weather.icon} ${weather.name}`;
    }
    
    function updateWeatherEffects() {
        const overlay = document.getElementById('weather-overlay');
        overlay.innerHTML = '';
        
        if (game.weather === 'rain') {
            for (let i = 0; i < 50; i++) {
                const drop = document.createElement('div');
                drop.className = 'rain-drop';
                drop.style.left = rand(0, 100) + '%';
                drop.style.animationDelay = rand(0, 0.5) + 's';
                drop.style.animationDuration = rand(0.3, 0.6) + 's';
                overlay.appendChild(drop);
            }
        } else if (game.weather === 'snow') {
            for (let i = 0; i < 30; i++) {
                const flake = document.createElement('div');
                flake.className = 'snow-flake';
                flake.style.left = rand(0, 100) + '%';
                flake.style.animationDelay = rand(0, 3) + 's';
                flake.style.width = rand(4, 10) + 'px';
                flake.style.height = flake.style.width;
                overlay.appendChild(flake);
            }
        }
    }
    
    // ============= STAGE SYSTEM =============
    function checkStageProgress() {
        game.stageKills++;
        
        if (game.stageKills >= game.stageKillsNeeded && !game.enemies.some(e => e.isBoss)) {
            // Spawn stage boss
            const stage = STAGES[game.currentStage];
            const p = game.player;
            const angle = rand(0, Math.PI * 2);
            const x = clamp(p.x + Math.cos(angle) * 300, 100, WORLD_W - 100);
            const y = clamp(p.y + Math.sin(angle) * 300, 100, WORLD_H - 100);
            
            const boss = new Enemy(x, y, stage.boss, game.wave);
            boss.isStageBoss = true;
            game.enemies.push(boss);
            
            audio.play('boss');
            spawnFloatingText(p.x, p.y - 60, '⚠️ 스테이지 보스 등장!', '#ef4444', 28);
        }
    }
    
    function advanceToNextStage() {
        if (game.currentStage >= STAGES.length - 1) {
            // Victory!
            spawnFloatingText(game.player.x, game.player.y, '🎉 모든 스테이지 클리어!', '#ffd700', 36);
            return;
        }
        
        game.currentStage++;
        game.stageKills = 0;
        game.stageKillsNeeded = 30 + game.currentStage * 10;
        game.wave = 1 + game.currentStage * 5;
        
        // Stage transition
        const transition = document.getElementById('stage-transition');
        const nextStage = STAGES[game.currentStage];
        document.getElementById('next-stage-name').textContent = nextStage.name + ' - ' + nextStage.desc;
        transition.classList.add('show');
        game.paused = true;
        
        setTimeout(() => {
            transition.classList.remove('show');
            game.paused = false;
            
            // Regenerate terrain for new stage
            generateTerrain();
            
            // Update UI
            document.getElementById('stage-name').textContent = nextStage.name;
            
            // Give skill point
            game.skillPoints++;
            spawnFloatingText(game.player.x, game.player.y, '+1 스킬 포인트!', '#22d3ee', 24);
            
            // Heal player
            game.player.hp = game.player.maxHp;
            game.player.mp = game.player.maxMp;
        }, 2000);
    }
    
    // ============= BOSS GIMMICK SYSTEM =============
    function triggerBossGimmick(boss) {
        const gimmicks = BOSS_GIMMICKS[boss.type];
        if (!gimmicks) return;
        
        const gimmick = gimmicks[randInt(0, gimmicks.length - 1)];
        game.bossGimmickActive = true;
        game.bossGimmickData = { boss, gimmick, timer: 180 };
        
        // Show warning
        const warning = document.getElementById('gimmick-warning');
        warning.querySelector('.warning-text').textContent = `⚠️ ${gimmick.name}!`;
        warning.querySelector('.warning-desc').textContent = gimmick.desc;
        warning.classList.add('show');
        
        setTimeout(() => {
            warning.classList.remove('show');
            executeBossGimmick(boss, gimmick);
        }, 1500);
    }
    
    function executeBossGimmick(boss, gimmick) {
        const p = game.player;
        
        switch(gimmick.type) {
            case 'fire_zone':
                // Create fire zones
                for (let i = 0; i < 5; i++) {
                    game.hazardZones.push({
                        x: p.x + rand(-200, 200),
                        y: p.y + rand(-200, 200),
                        radius: 60,
                        type: 'fire',
                        damage: 5,
                        duration: 300,
                        color: '#ef4444'
                    });
                }
                break;
                
            case 'fly_attack':
                boss.flying = true;
                boss.invulnerable = true;
                setTimeout(() => {
                    boss.flying = false;
                    boss.invulnerable = false;
                    // Landing damage
                    if (dist(boss, p) < 150) {
                        p.takeDamage(boss.atk * 2);
                    }
                    game.camera.shake = 20;
                    for (let i = 0; i < 30; i++) {
                        game.particles.push(createParticle(boss.x, boss.y, '#f97316', rand(5, 15), 40));
                    }
                }, 2000);
                break;
                
            case 'breath':
                for (let i = -4; i <= 4; i++) {
                    const a = boss.angle + i * 0.2;
                    game.projectiles.push(createProjectile(boss.x, boss.y, a, {
                        damage: boss.atk, color: '#f97316', fromPlayer: false, speed: 8, life: 60
                    }));
                }
                break;
                
            case 'soul_explosion':
                for (let i = 0; i < 8; i++) {
                    const a = (i / 8) * Math.PI * 2;
                    const x = boss.x + Math.cos(a) * 100;
                    const y = boss.y + Math.sin(a) * 100;
                    setTimeout(() => {
                        if (dist({ x, y }, p) < 80) {
                            p.takeDamage(boss.atk);
                        }
                        for (let j = 0; j < 15; j++) {
                            game.particles.push(createParticle(x, y, '#a855f7', rand(5, 12), 30));
                        }
                    }, i * 200);
                }
                break;
                
            case 'mass_summon':
                for (let i = 0; i < 6; i++) {
                    const a = rand(0, Math.PI * 2);
                    game.enemies.push(new Enemy(
                        boss.x + Math.cos(a) * 80,
                        boss.y + Math.sin(a) * 80,
                        'skeleton', game.wave
                    ));
                }
                break;
                
            case 'curse_zone':
                game.hazardZones.push({
                    x: p.x,
                    y: p.y,
                    radius: 120,
                    type: 'curse',
                    damage: 3,
                    duration: 480,
                    color: '#a855f7'
                });
                break;
                
            case 'earthquake':
                game.camera.shake = 30;
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        game.camera.shake = 15;
                        // Damage if player is not jumping (always damages for now)
                        if (Math.random() < 0.5) p.takeDamage(boss.atk * 0.5);
                    }, i * 300);
                }
                break;
                
            case 'charge':
                const chargeAngle = Math.atan2(p.y - boss.y, p.x - boss.x);
                boss.charging = true;
                const chargeInterval = setInterval(() => {
                    boss.x += Math.cos(chargeAngle) * 15;
                    boss.y += Math.sin(chargeAngle) * 15;
                    if (dist(boss, p) < 50) {
                        p.takeDamage(boss.atk * 1.5);
                    }
                }, 16);
                setTimeout(() => {
                    clearInterval(chargeInterval);
                    boss.charging = false;
                }, 1000);
                break;
                
            case 'enrage':
                boss.enraged = true;
                boss.speed *= 1.5;
                boss.atk *= 1.5;
                spawnFloatingText(boss.x, boss.y - 50, '😡 분노!', '#ef4444', 28);
                break;
        }
    }
    
    function updateHazardZones() {
        game.hazardZones = game.hazardZones.filter(zone => {
            zone.duration--;
            
            // Check player collision
            if (dist(zone, game.player) < zone.radius) {
                if (game.tick % 30 === 0) {
                    game.player.takeDamage(zone.damage);
                }
            }
            
            return zone.duration > 0;
        });
    }

    // ============= SPAWN SYSTEM =============
    function spawnWave() {
        game.waveTimer++;
        
        // Update time and weather
        if (game.tick % 60 === 0) {
            updateTimeAndWeather();
        }
        
        // Update hazard zones
        updateHazardZones();
        
        const stage = STAGES[game.currentStage];
        const timePhase = TIME_PHASES[game.timeOfDay];
        const spawnRate = Math.max(60, 120 - game.wave * 3);
        
        if (game.waveTimer >= spawnRate) {
            game.waveTimer = 0;
            
            const p = game.player;
            const angle = rand(0, Math.PI * 2);
            const r = 400 + rand(0, 200);
            const x = clamp(p.x + Math.cos(angle) * r, 50, WORLD_W - 50);
            const y = clamp(p.y + Math.sin(angle) * r, 50, WORLD_H - 50);
            
            // Enemy type based on current stage
            const stageEnemies = stage.enemies;
            let type = stageEnemies[randInt(0, stageEnemies.length - 1)];
            
            // More enemies at night
            const enemyCount = timePhase.enemyMult > 1 && Math.random() < 0.3 ? 2 : 1;
            
            for (let i = 0; i < enemyCount; i++) {
                const ex = x + (i * 30);
                const ey = y + (i * 30);
                game.enemies.push(new Enemy(clamp(ex, 50, WORLD_W-50), clamp(ey, 50, WORLD_H-50), type, game.wave));
            }
        }
        
        // Wave progression
        if (game.player.kills >= game.wave * 10) {
            game.wave++;
            spawnFloatingText(game.player.x, game.player.y - 50, `WAVE ${game.wave}`, '#fbbf24', 28);
        }
        
        // Boss gimmick trigger
        const activeBoss = game.enemies.find(e => e.isBoss);
        if (activeBoss && !game.bossGimmickActive) {
            if (activeBoss.hp < activeBoss.maxHp * 0.7 && !activeBoss.gimmick1) {
                activeBoss.gimmick1 = true;
                triggerBossGimmick(activeBoss);
            }
            if (activeBoss.hp < activeBoss.maxHp * 0.4 && !activeBoss.gimmick2) {
                activeBoss.gimmick2 = true;
                triggerBossGimmick(activeBoss);
            }
        }
        
        // Reset gimmick state
        if (game.bossGimmickData && game.bossGimmickData.timer > 0) {
            game.bossGimmickData.timer--;
            if (game.bossGimmickData.timer <= 0) {
                game.bossGimmickActive = false;
                game.bossGimmickData = null;
            }
        }
    }

    // ============= LEVEL UP MODAL =============
    function showLevelUpModal() {
        game.paused = true;
        const modal = document.getElementById('levelup-modal');
        modal.classList.add('show');
        
        const container = document.getElementById('upgrade-cards');
        container.innerHTML = '';
        
        const pool = [...UPGRADES];
        const picks = [];
        for (let i = 0; i < 3 && pool.length > 0; i++) {
            const idx = randInt(0, pool.length - 1);
            picks.push(pool[idx]);
            pool.splice(idx, 1);
        }
        
        picks.forEach(up => {
            const card = document.createElement('div');
            card.className = 'upgrade-card';
            card.style.setProperty('--card-color', up.color);
            card.style.setProperty('--card-glow', up.color + '44');
            card.innerHTML = `
                <div style="font-size: 3rem; margin-bottom: 15px;">${up.icon}</div>
                <div style="font-weight: bold; font-size: 1.1rem; color: ${up.color}; margin-bottom: 10px;">${up.name}</div>
                <div style="color: #888; font-size: 0.9rem;">${up.desc}</div>
            `;
            card.onclick = () => selectUpgrade(up);
            container.appendChild(card);
        });
    }

    function selectUpgrade(up) {
        up.apply(game.player);
        document.getElementById('levelup-modal').classList.remove('show');
        game.paused = false;
        spawnFloatingText(game.player.x, game.player.y - 40, up.name, up.color, 22);
    }

    // ============= GAME OVER =============
    function gameOver() {
        game.running = false;
        
        const elapsed = Math.floor((Date.now() - game.startTime) / 1000);
        const mins = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const secs = String(elapsed % 60).padStart(2, '0');
        
        document.getElementById('go-level').textContent = game.player.level;
        document.getElementById('go-wave').textContent = game.wave;
        document.getElementById('go-kills').textContent = game.player.kills;
        document.getElementById('go-gold').textContent = game.player.gold;
        document.getElementById('go-combo').textContent = game.player.maxCombo;
        document.getElementById('go-time').textContent = `${mins}:${secs}`;
        
        document.getElementById('gameover-modal').classList.add('show');
    }

    // ============= UPDATE & DRAW =============
    function update() {
        if (!game.running || game.paused) return;
        
        game.tick++;
        game.player.update();
        
        // Camera
        game.camera.x = lerp(game.camera.x, game.player.x - canvas.width / 2, 0.08);
        game.camera.y = lerp(game.camera.y, game.player.y - canvas.height / 2, 0.08);
        game.camera.x = clamp(game.camera.x, 0, WORLD_W - canvas.width);
        game.camera.y = clamp(game.camera.y, 0, WORLD_H - canvas.height);
        if (game.camera.shake > 0.5) game.camera.shake *= 0.9;
        else game.camera.shake = 0;
        
        spawnWave();
        
        game.enemies.forEach(e => e.update());
        
        // Projectiles
        game.projectiles = game.projectiles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            
            if (p.fromPlayer) {
                game.enemies.forEach(e => {
                    if (p.hitList.has(e)) return;
                    if (dist(p, e) < p.radius + e.radius) {
                        p.hitList.add(e);
                        e.takeDamage(p.damage, false, p.angle);
                        
                        if (p.freeze) e.frozen = 120;
                        if (p.poison) { e.poisoned = 180; e.poisonDmg = p.damage * 0.2; }
                        if (p.slow) e.speed *= 0.5;
                        
                        if (p.explode) {
                            game.enemies.forEach(e2 => {
                                if (dist(p, e2) < 60) e2.takeDamage(p.damage * 0.5, false, 0);
                            });
                            for (let i = 0; i < 15; i++) {
                                game.particles.push(createParticle(p.x, p.y, '#f97316', 8, 25));
                            }
                            p.life = 0;
                        }
                        
                        p.pierce--;
                        if (p.pierce <= 0) p.life = 0;
                    }
                });
            } else {
                if (dist(p, game.player) < p.radius + game.player.radius) {
                    game.player.takeDamage(p.damage);
                    p.life = 0;
                }
            }
            
            return p.life > 0 && p.x > 0 && p.x < WORLD_W && p.y > 0 && p.y < WORLD_H;
        });
        
        // Particles
        game.particles = game.particles.filter(p => {
            if (p.type === 'slash') {
                p.life--;
                return p.life > 0;
            }
            p.x += p.vx;
            p.y += p.vy;
            p.vx *= 0.95;
            p.vy *= 0.95;
            p.life--;
            return p.life > 0;
        });
        
        // Floating texts
        game.floatingTexts = game.floatingTexts.filter(t => {
            t.y -= 1.5;
            t.life--;
            return t.life > 0;
        });
        
        // Loot
        game.loot = game.loot.filter(l => {
            const d = dist(l, game.player);
            if (d < 100) {
                const a = Math.atan2(game.player.y - l.y, game.player.x - l.x);
                l.x += Math.cos(a) * 8;
                l.y += Math.sin(a) * 8;
            }
            if (d < 25) {
                if (l.type === 'health') {
                    game.player.hp = Math.min(game.player.maxHp, game.player.hp + l.value);
                    spawnFloatingText(l.x, l.y, `+${l.value}`, '#22c55e');
                } else if (l.type === 'mana') {
                    game.player.mp = Math.min(game.player.maxMp, game.player.mp + l.value);
                    spawnFloatingText(l.x, l.y, `+${l.value}`, '#3b82f6');
                }
                audio.play('pickup');
                return false;
            }
            return true;
        });
        
        // Summons
        game.summons = game.summons.filter(s => {
            s.duration--;
            
            const nearest = game.enemies.reduce((b, e) => (!b || dist(s, e) < dist(s, b)) ? e : b, null);
            if (nearest && dist(s, nearest) < 300) {
                const a = Math.atan2(nearest.y - s.y, nearest.x - s.x);
                s.x += Math.cos(a) * 3;
                s.y += Math.sin(a) * 3;
                
                if (dist(s, nearest) < 30) {
                    nearest.takeDamage(s.atk, false, a);
                }
            }
            
            return s.duration > 0 && s.hp > 0;
        });
        
        // Traps
        game.traps = game.traps.filter(t => {
            t.duration--;
            return t.duration > 0;
        });
        
        updateUI();
    }

    function draw() {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        
        // Camera shake
        const shake = game.camera.shake;
        ctx.translate(rand(-shake, shake), rand(-shake, shake));
        
        const camX = game.camera.x;
        const camY = game.camera.y;
        
        // Draw terrain
        drawTerrain(camX, camY);
        
        // Traps
        game.traps.forEach(t => {
            ctx.fillStyle = 'rgba(161, 98, 7, 0.2)';
            ctx.beginPath();
            ctx.arc(t.x - camX, t.y - camY, t.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#a16207';
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        });
        
        // Loot
        game.loot.forEach(l => {
            const cx = l.x - camX;
            const cy = l.y - camY + Math.sin(Date.now() / 200) * 3;
            ctx.fillStyle = l.type === 'health' ? '#ef4444' : '#3b82f6';
            ctx.shadowColor = ctx.fillStyle;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(l.type === 'health' ? '❤️' : '💎', cx, cy + 4);
        });
        
        // Summons
        game.summons.forEach(s => {
            ctx.fillStyle = s.type === 'angel' ? '#fbbf24' : '#888';
            ctx.shadowColor = ctx.fillStyle;
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(s.x - camX, s.y - camY, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = '#fff';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(s.type === 'angel' ? '👼' : '💀', s.x - camX, s.y - camY + 5);
        });
        
        // Enemies
        game.enemies.forEach(e => e.draw());
        
        // Player
        if (game.player) game.player.draw();
        
        // Projectiles
        game.projectiles.forEach(p => {
            const cx = p.x - camX;
            const cy = p.y - camY;
            
            ctx.fillStyle = p.color;
            ctx.shadowColor = p.color;
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(cx, cy, p.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        });
        
        // Particles with enhanced rendering
        game.particles.forEach(p => {
            const cx = p.x - camX;
            const cy = p.y - camY;
            let alpha = p.life / p.maxLife;
            
            if (p.fadeIn && p.life > p.maxLife * 0.8) {
                alpha = (p.maxLife - p.life) / (p.maxLife * 0.2);
            }
            
            ctx.globalAlpha = alpha;
            
            if (p.type === 'slash') {
                const progress = 1 - p.life / p.maxLife;
                const thickness = (p.thickness || 4) * alpha;
                
                // Outer glow
                ctx.strokeStyle = p.color;
                ctx.lineWidth = thickness + 8;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 25;
                ctx.globalAlpha = alpha * 0.3;
                ctx.beginPath();
                ctx.arc(cx, cy, p.range * (0.6 + progress * 0.4), p.angle - (p.arc || 0.6), p.angle + (p.arc || 0.6));
                ctx.stroke();
                
                // Main slash
                ctx.globalAlpha = alpha;
                ctx.lineWidth = thickness;
                ctx.beginPath();
                ctx.arc(cx, cy, p.range * (0.6 + progress * 0.4), p.angle - (p.arc || 0.6), p.angle + (p.arc || 0.6));
                ctx.stroke();
                
                // Inner bright core
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = thickness * 0.4;
                ctx.globalAlpha = alpha * 0.8;
                ctx.beginPath();
                ctx.arc(cx, cy, p.range * (0.6 + progress * 0.4), p.angle - (p.arc || 0.6) * 0.8, p.angle + (p.arc || 0.6) * 0.8);
                ctx.stroke();
                
                ctx.shadowBlur = 0;
                
                // Secondary slash effect
                if (p.secondary && p.trail) {
                    ctx.globalAlpha = alpha * 0.5;
                    ctx.strokeStyle = p.secondary;
                    ctx.lineWidth = thickness * 0.5;
                    ctx.beginPath();
                    ctx.arc(cx, cy, p.range * (0.5 + progress * 0.3), p.angle - (p.arc || 0.6) * 1.2, p.angle + (p.arc || 0.6) * 1.2);
                    ctx.stroke();
                }
                
            } else if (p.type === 'ring') {
                const progress = 1 - p.life / p.maxLife;
                const currentRadius = p.maxRadius * progress;
                
                ctx.strokeStyle = p.color;
                ctx.lineWidth = p.thickness * alpha;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(cx, cy, currentRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
            } else if (p.type === 'flash') {
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, p.size);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(0.3, p.color);
                grad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(cx, cy, p.size * (1 + (1 - alpha) * 0.5), 0, Math.PI * 2);
                ctx.fill();
                
            } else if (p.type === 'spark' || p.type === 'trail') {
                // Draw trail
                if (p.trail) {
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = p.size * 0.5;
                    ctx.globalAlpha = alpha * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx - p.vx * 3, cy - p.vy * 3);
                    ctx.stroke();
                }
                
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#fff';
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(cx, cy, p.size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(cx, cy, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
            } else if (p.type === 'star') {
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(p.angle);
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 15;
                
                // Draw star shape
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const outerAngle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                    const innerAngle = outerAngle + Math.PI / 5;
                    const outerX = Math.cos(outerAngle) * p.size;
                    const outerY = Math.sin(outerAngle) * p.size;
                    const innerX = Math.cos(innerAngle) * (p.size * 0.4);
                    const innerY = Math.sin(innerAngle) * (p.size * 0.4);
                    
                    if (i === 0) ctx.moveTo(outerX, outerY);
                    else ctx.lineTo(outerX, outerY);
                    ctx.lineTo(innerX, innerY);
                }
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
                
            } else if (p.type === 'fire') {
                const grad = ctx.createRadialGradient(cx, cy - p.size * 0.3, 0, cx, cy, p.size);
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.3, p.color);
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.ellipse(cx, cy, p.size * 0.7, p.size, 0, 0, Math.PI * 2);
                ctx.fill();
                
            } else if (p.type === 'ice') {
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(p.angle);
                ctx.fillStyle = p.color;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 12;
                
                // Diamond shape
                ctx.beginPath();
                ctx.moveTo(0, -p.size);
                ctx.lineTo(p.size * 0.6, 0);
                ctx.lineTo(0, p.size);
                ctx.lineTo(-p.size * 0.6, 0);
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
                
            } else if (p.type === 'lightning') {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                let lx = cx, ly = cy;
                for (let i = 0; i < 3; i++) {
                    lx += rand(-10, 10);
                    ly += rand(-10, 10);
                    ctx.lineTo(lx, ly);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
                
            } else if (p.type === 'holy') {
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(cx, cy, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(cx, cy, p.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
            } else if (p.type === 'dark') {
                ctx.fillStyle = p.color;
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(cx, cy, p.size, 0, Math.PI * 2);
                ctx.fill();
                // Inner void
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.beginPath();
                ctx.arc(cx, cy, p.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
            } else {
                // Default circle particle
                if (p.glow) {
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 12;
                }
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(cx, cy, p.size * alpha * (p.scale || 1), 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            ctx.globalAlpha = 1;
        });
        
        // Floating texts
        game.floatingTexts.forEach(t => {
            const cx = t.x - camX;
            const cy = t.y - camY;
            const alpha = t.life / 60;
            
            ctx.globalAlpha = alpha;
            ctx.font = `bold ${t.size}px 'Cinzel', serif`;
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText(t.text, cx, cy);
            ctx.fillStyle = t.color;
            ctx.fillText(t.text, cx, cy);
            ctx.globalAlpha = 1;
        });
        
        ctx.restore();
        
        // Minimap
        drawMinimap();
    }

    function drawTerrain(camX, camY) {
        // Ground color based on stage
        const stage = STAGES[game.currentStage];
        ctx.fillStyle = stage.bgColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Time of day overlay
        const timePhase = TIME_PHASES[game.timeOfDay];
        if (timePhase.brightness < 1) {
            ctx.fillStyle = `rgba(0, 0, 30, ${1 - timePhase.brightness})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Weather effects on visibility
        const weather = WEATHER_TYPES[game.weather];
        if (weather.effects.visibility && weather.effects.visibility < 1) {
            ctx.fillStyle = `rgba(100, 100, 100, ${1 - weather.effects.visibility})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1;
        const gridSize = 100;
        for (let x = -camX % gridSize; x < canvas.width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
        for (let y = -camY % gridSize; y < canvas.height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
        
        // Decorations
        game.decorations.forEach(d => {
            const dx = d.x - camX;
            const dy = d.y - camY;
            if (dx < -50 || dx > canvas.width + 50 || dy < -50 || dy > canvas.height + 50) return;
            
            if (d.type === 'grass') {
                ctx.fillStyle = d.color;
                ctx.beginPath();
                for (let i = 0; i < 3; i++) {
                    ctx.moveTo(dx + i * 5, dy);
                    ctx.lineTo(dx + i * 5 + 2, dy - d.size);
                    ctx.lineTo(dx + i * 5 + 4, dy);
                }
                ctx.fill();
            } else if (d.type === 'flower') {
                ctx.fillStyle = d.color;
                ctx.beginPath();
                ctx.arc(dx, dy, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(dx, dy, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (d.type === 'path') {
                ctx.fillStyle = 'rgba(139, 119, 101, 0.3)';
                ctx.beginPath();
                ctx.arc(dx, dy, d.size, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        
        // Water
        game.terrain.forEach(t => {
            if (t.type !== 'water') return;
            const dx = t.x - camX;
            const dy = t.y - camY;
            if (dx < -200 || dx > canvas.width + 200 || dy < -200 || dy > canvas.height + 200) return;
            
            ctx.fillStyle = 'rgba(59, 130, 246, 0.4)';
            ctx.beginPath();
            ctx.arc(dx, dy, t.radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(96, 165, 250, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(dx, dy, t.radius - 5, 0, Math.PI * 2);
            ctx.stroke();
        });
        
        // Trees
        game.trees.forEach(t => {
            const dx = t.x - camX;
            const dy = t.y - camY;
            if (dx < -100 || dx > canvas.width + 100 || dy < -100 || dy > canvas.height + 100) return;
            
            // Trunk
            ctx.fillStyle = t.trunkColor;
            ctx.fillRect(dx - 5, dy - 10, 10, 30);
            
            // Leaves
            ctx.fillStyle = t.leafColor;
            ctx.beginPath();
            ctx.arc(dx, dy - 25, t.size * 0.6, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // Rocks
        game.terrain.forEach(t => {
            if (t.type !== 'rock') return;
            const dx = t.x - camX;
            const dy = t.y - camY;
            if (dx < -50 || dx > canvas.width + 50 || dy < -50 || dy > canvas.height + 50) return;
            
            ctx.fillStyle = t.color;
            ctx.beginPath();
            ctx.ellipse(dx, dy, t.size, t.size * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // World border
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 4;
        ctx.shadowColor = '#ef4444';
        ctx.shadowBlur = 20;
        ctx.strokeRect(-camX, -camY, WORLD_W, WORLD_H);
        ctx.shadowBlur = 0;
        
        // Draw hazard zones
        game.hazardZones.forEach(zone => {
            const zx = zone.x - camX;
            const zy = zone.y - camY;
            
            ctx.fillStyle = zone.color + '44';
            ctx.beginPath();
            ctx.arc(zx, zy, zone.radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = zone.color;
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Pulsing effect
            const pulse = Math.sin(Date.now() / 200) * 10;
            ctx.strokeStyle = zone.color + '88';
            ctx.beginPath();
            ctx.arc(zx, zy, zone.radius + pulse, 0, Math.PI * 2);
            ctx.stroke();
        });
    }

    function drawMinimap() {
        const mw = 150, mh = 150;
        const scale = mw / WORLD_W;
        
        minimapCtx.fillStyle = 'rgba(20, 20, 35, 0.9)';
        minimapCtx.fillRect(0, 0, mw, mh);
        
        // Viewport
        const vx = game.camera.x * scale;
        const vy = game.camera.y * scale;
        const vw = canvas.width * scale;
        const vh = canvas.height * scale;
        minimapCtx.strokeStyle = 'rgba(255,255,255,0.3)';
        minimapCtx.strokeRect(vx, vy, vw, vh);
        
        // Enemies
        minimapCtx.fillStyle = '#ef4444';
        game.enemies.forEach(e => {
            const size = e.isBoss ? 4 : 2;
            minimapCtx.beginPath();
            minimapCtx.arc(e.x * scale, e.y * scale, size, 0, Math.PI * 2);
            minimapCtx.fill();
        });
        
        // Player
        if (game.player) {
            minimapCtx.fillStyle = game.player.color;
            minimapCtx.beginPath();
            minimapCtx.arc(game.player.x * scale, game.player.y * scale, 4, 0, Math.PI * 2);
            minimapCtx.fill();
        }
    }

    function updateUI() {
        if (!game.player) return;
        const p = game.player;
        
        document.getElementById('player-icon').textContent = p.icon;
        document.getElementById('player-icon').style.background = `linear-gradient(135deg, ${p.color}, ${p.color}88)`;
        document.getElementById('player-class').textContent = p.className;
        document.getElementById('player-class').style.color = p.color;
        document.getElementById('player-level').textContent = p.level;
        document.getElementById('wave-num').textContent = game.wave;
        
        document.getElementById('hp-bar').style.width = `${(p.hp / p.maxHp) * 100}%`;
        document.getElementById('hp-text').textContent = `${Math.ceil(p.hp)} / ${p.maxHp}`;
        
        document.getElementById('mp-bar').style.width = `${(p.mp / p.maxMp) * 100}%`;
        document.getElementById('mp-text').textContent = `${Math.ceil(p.mp)} / ${p.maxMp}`;
        
        document.getElementById('exp-bar').style.width = `${(p.exp / p.nextExp) * 100}%`;
        document.getElementById('exp-text').textContent = `${Math.floor(p.exp)} / ${p.nextExp}`;
        
        const dashPct = p.dashCooldown > 0 ? 100 - (p.dashCooldown / p.dashCooldownMax) * 100 : 100;
        document.getElementById('dash-bar').style.width = `${dashPct}%`;
        
        document.getElementById('stat-atk').textContent = p.atk;
        document.getElementById('stat-def').textContent = p.def;
        document.getElementById('stat-spd').textContent = p.spd.toFixed(1);
        document.getElementById('stat-crit').textContent = `${Math.round(p.critRate * 100)}%`;
        document.getElementById('stat-kills').textContent = p.kills;
        document.getElementById('stat-gold').textContent = p.gold;
        
        const elapsed = Math.floor((Date.now() - game.startTime) / 1000);
        const mins = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const secs = String(elapsed % 60).padStart(2, '0');
        document.getElementById('stat-time').textContent = `${mins}:${secs}`;
        
        // Combo
        const comboEl = document.getElementById('combo-display');
        if (p.combo >= 5) {
            comboEl.classList.add('show');
            document.getElementById('combo-count').textContent = p.combo;
        } else {
            comboEl.classList.remove('show');
        }
        
        // Skills
        const skillBar = document.getElementById('skills-bar');
        if (skillBar.children.length === 0) {
            p.skills.forEach((s, i) => {
                const slot = document.createElement('div');
                slot.className = 'skill-slot';
                slot.dataset.index = i;
                slot.innerHTML = `
                    <span class="skill-key">${i + 1}</span>
                    <span class="skill-icon">${s.icon}</span>
                    <span class="skill-level">Lv.${s.unlockLv}</span>
                `;
                slot.title = `${s.name}: ${s.desc} (MP: ${s.cost})`;
                slot.onclick = () => p.useSkill(i);
                skillBar.appendChild(slot);
            });
        }
        
        document.querySelectorAll('.skill-slot').forEach((slot, i) => {
            const s = p.skills[i];
            const locked = s.unlockLv > p.level;
            const onCooldown = s.cooldownTimer > 0;
            
            slot.classList.toggle('locked', locked);
            slot.classList.toggle('on-cooldown', onCooldown);
            
            // Remove old overlay
            const oldOverlay = slot.querySelector('.cooldown-overlay');
            if (oldOverlay) oldOverlay.remove();
            
            if (onCooldown) {
                const overlay = document.createElement('div');
                overlay.className = 'cooldown-overlay';
                overlay.textContent = Math.ceil(s.cooldownTimer / 60);
                slot.appendChild(overlay);
            }
        });
        
        // Buffs
        const buffContainer = document.getElementById('buff-container');
        buffContainer.innerHTML = '';
        p.buffs.forEach(b => {
            const el = document.createElement('div');
            el.className = 'buff-icon';
            el.style.background = `${b.color}33`;
            el.style.border = `2px solid ${b.color}`;
            el.innerHTML = `${b.icon}<span class="buff-time">${Math.ceil(b.duration / 60)}s</span>`;
            buffContainer.appendChild(el);
        });
        
        // Passive
        document.getElementById('passive-text').textContent = `${p.passive.name}: ${p.passive.desc}`;
        
        // Boss HP (hide if no boss)
        if (!game.enemies.some(e => e.isBoss)) {
            document.getElementById('boss-hp-container').style.display = 'none';
        }
        
        // Update mobile skill buttons
        updateMobileSkillButtons();
    }

    // ============= MENU SETUP =============
    function setupMenu() {
        const grid = document.getElementById('class-grid');
        
        Object.entries(CLASSES).forEach(([key, c]) => {
            const card = document.createElement('div');
            card.className = 'class-card';
            card.dataset.class = key;
            card.style.setProperty('--class-color', c.color);
            card.style.setProperty('--class-glow', c.color + '44');
            
            if (key === 'warrior') card.classList.add('selected');
            
            const attackTypeLabel = c.attackType === 'melee' ? '⚔️ 근접' : '🏹 원거리';
            
            card.innerHTML = `
                <div class="class-type-badge">${attackTypeLabel}</div>
                <div class="class-icon" style="background: linear-gradient(135deg, ${c.color}, ${c.color}88);">${c.icon}</div>
                <div class="class-name" style="color: ${c.color};">${c.name}</div>
                <div class="class-desc">${c.desc.substring(0, 30)}...</div>
                <div class="class-stats">
                    <div class="class-stat">
                        <span class="class-stat-value" style="color: #ef4444;">${c.atk}</span>
                        <span class="class-stat-label">ATK</span>
                    </div>
                    <div class="class-stat">
                        <span class="class-stat-value" style="color: #22c55e;">${c.hp}</span>
                        <span class="class-stat-label">HP</span>
                    </div>
                    <div class="class-stat">
                        <span class="class-stat-value" style="color: #3b82f6;">${c.mp}</span>
                        <span class="class-stat-label">MP</span>
                    </div>
                </div>
                <div class="class-passive" style="--class-color: ${c.color};">⭐ ${c.passive.name}</div>
            `;
            
            // 툴팁으로 상세 정보 표시
            card.title = `${c.name}\n\n${c.desc}\n\n📊 스탯:\nHP: ${c.hp} | MP: ${c.mp}\nATK: ${c.atk} | DEF: ${c.def}\nSPD: ${c.spd} | CRIT: ${Math.round(c.critRate * 100)}%\n\n⭐ 패시브: ${c.passive.name}\n${c.passive.desc}\n\n🔥 스킬:\n${c.skills.map(s => `[Lv.${s.unlockLv}] ${s.icon} ${s.name}: ${s.desc}`).join('\n')}`;
            
            card.onclick = () => {
                document.querySelectorAll('.class-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                game.selectedClass = key;
            };
            
            grid.appendChild(card);
        });
        
        document.getElementById('start-btn').onclick = startGame;
    }

    function startGame() {
        document.getElementById('main-menu').style.display = 'none';
        document.getElementById('game-ui').style.display = 'block';
        
        // Show mobile controls if on mobile
        if (isMobile) {
            document.getElementById('mobile-controls').classList.add('show');
        }
        
        generateTerrain();
        game.player = new Player(game.selectedClass);
        game.running = true;
        game.startTime = Date.now();
        
        // Resume audio context on user interaction (mobile requirement)
        if (audio.ctx.state === 'suspended') {
            audio.ctx.resume();
        }
        
        updateUI();
    }

    // ============= INPUT =============
    window.addEventListener('keydown', e => {
        game.input.keys[e.key] = true;
        if (e.key === 'Escape' && game.running) {
            // Close skill tree if open
            if (document.getElementById('skilltree-modal').classList.contains('show')) {
                document.getElementById('skilltree-modal').classList.remove('show');
            }
            game.paused = !game.paused;
        }
        if ((e.key === 't' || e.key === 'T') && game.running && !game.paused) {
            toggleSkillTree();
        }
    });
    
    // Skill Tree Functions
    function toggleSkillTree() {
        const modal = document.getElementById('skilltree-modal');
        if (modal.classList.contains('show')) {
            modal.classList.remove('show');
            game.paused = false;
        } else {
            modal.classList.add('show');
            game.paused = true;
            renderSkillTree();
        }
    }
    
    function renderSkillTree() {
        document.getElementById('st-points').textContent = game.skillPoints;
        
        ['offense', 'defense', 'utility'].forEach(category => {
            const container = document.getElementById('st-' + category);
            container.innerHTML = '';
            
            SKILL_TREE[category].forEach(skill => {
                const currentLv = game.skillTreeLevels[skill.id] || 0;
                const isMaxed = currentLv >= skill.maxLv;
                const canUpgrade = game.skillPoints > 0 && !isMaxed;
                
                const node = document.createElement('div');
                node.className = 'skill-tree-node' + (isMaxed ? ' maxed' : '') + (!canUpgrade ? ' locked' : '');
                node.innerHTML = `
                    <div class="node-icon">${skill.icon}</div>
                    <div class="node-name">${skill.name}</div>
                    <div class="node-level">${currentLv} / ${skill.maxLv}</div>
                    <div class="node-desc">${skill.desc}</div>
                `;
                
                if (canUpgrade) {
                    node.onclick = () => upgradeSkillNode(skill);
                }
                
                container.appendChild(node);
            });
        });
    }
    
    function upgradeSkillNode(skill) {
        if (game.skillPoints <= 0) return;
        
        const currentLv = game.skillTreeLevels[skill.id] || 0;
        if (currentLv >= skill.maxLv) return;
        
        game.skillPoints--;
        game.skillTreeLevels[skill.id] = currentLv + 1;
        
        // Apply effect
        skill.effect(game.player);
        
        // Play sound
        audio.play('levelup');
        
        renderSkillTree();
    }
    
    // Skill tree button click
    document.getElementById('skilltree-btn')?.addEventListener('click', toggleSkillTree);
    window.addEventListener('keyup', e => game.input.keys[e.key] = false);
    window.addEventListener('mousemove', e => {
        game.input.mouse.x = e.clientX;
        game.input.mouse.y = e.clientY;
    });
    window.addEventListener('mousedown', e => {
        if (e.button === 0) game.input.mouse.down = true;
        if (e.button === 2) game.input.mouse.right = true;
    });
    window.addEventListener('mouseup', e => {
        if (e.button === 0) game.input.mouse.down = false;
        if (e.button === 2) game.input.mouse.right = false;
    });
    window.addEventListener('contextmenu', e => e.preventDefault());
    
    // ============= MOBILE/TOUCH CONTROLS =============
    let isMobile = false;
    let joystickActive = false;
    let joystickTouchId = null;
    let joystickCenter = { x: 0, y: 0 };
    let joystickVector = { x: 0, y: 0 };
    let attackTouchId = null;
    let mobileAimAngle = 0;
    
    // Detect mobile/touch device
    function detectMobile() {
        isMobile = ('ontouchstart' in window) || 
                   (navigator.maxTouchPoints > 0) || 
                   (navigator.msMaxTouchPoints > 0) ||
                   window.innerWidth <= 1024;
        
        if (isMobile) {
            document.getElementById('mobile-controls').classList.add('show');
            canvas.style.cursor = 'default';
        } else {
            document.getElementById('mobile-controls').classList.remove('show');
            canvas.style.cursor = 'crosshair';
        }
    }
    
    detectMobile();
    window.addEventListener('resize', detectMobile);
    
    // Update control hints based on device
    function updateControlHints() {
        const desktopHint = document.querySelector('.desktop-hint');
        const mobileHint = document.querySelector('.mobile-hint');
        if (desktopHint && mobileHint) {
            desktopHint.style.display = isMobile ? 'none' : 'inline';
            mobileHint.style.display = isMobile ? 'inline' : 'none';
        }
    }
    updateControlHints();
    window.addEventListener('resize', updateControlHints);
    
    // Joystick handlers
    const joystickContainer = document.getElementById('joystick-container');
    const joystickBase = document.getElementById('joystick-base');
    const joystickStick = document.getElementById('joystick-stick');
    
    function getJoystickCenter() {
        const rect = joystickBase.getBoundingClientRect();
        return {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
        };
    }
    
    function updateJoystick(touchX, touchY) {
        const center = getJoystickCenter();
        const maxDist = 40;
        
        let dx = touchX - center.x;
        let dy = touchY - center.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
        }
        
        joystickStick.style.left = (40 + dx) + 'px';
        joystickStick.style.top = (40 + dy) + 'px';
        
        // Normalize for input
        joystickVector.x = dx / maxDist;
        joystickVector.y = dy / maxDist;
        
        // Update aim angle based on joystick
        if (dist > 10) {
            mobileAimAngle = Math.atan2(dy, dx);
        }
    }
    
    function resetJoystick() {
        joystickStick.style.left = '40px';
        joystickStick.style.top = '40px';
        joystickVector = { x: 0, y: 0 };
        joystickActive = false;
        joystickTouchId = null;
    }
    
    // Touch event handlers for joystick
    joystickContainer.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        joystickTouchId = touch.identifier;
        joystickActive = true;
        updateJoystick(touch.clientX, touch.clientY);
    }, { passive: false });
    
    window.addEventListener('touchmove', (e) => {
        for (let touch of e.changedTouches) {
            if (touch.identifier === joystickTouchId) {
                e.preventDefault();
                updateJoystick(touch.clientX, touch.clientY);
            }
        }
    }, { passive: false });
    
    window.addEventListener('touchend', (e) => {
        for (let touch of e.changedTouches) {
            if (touch.identifier === joystickTouchId) {
                resetJoystick();
            }
            if (touch.identifier === attackTouchId) {
                game.input.mouse.down = false;
                attackTouchId = null;
            }
        }
    });
    
    window.addEventListener('touchcancel', (e) => {
        resetJoystick();
        game.input.mouse.down = false;
        attackTouchId = null;
    });
    
    // Attack button
    const attackBtn = document.getElementById('attack-btn');
    attackBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        attackTouchId = e.changedTouches[0].identifier;
        game.input.mouse.down = true;
        
        // Vibration feedback if available
        if (navigator.vibrate) navigator.vibrate(30);
    }, { passive: false });
    
    attackBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        game.input.mouse.down = false;
        attackTouchId = null;
    }, { passive: false });
    
    // Dash button
    const dashBtn = document.getElementById('dash-btn');
    dashBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        game.input.keys['Shift'] = true;
        if (navigator.vibrate) navigator.vibrate(50);
    }, { passive: false });
    
    dashBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        game.input.keys['Shift'] = false;
    }, { passive: false });
    
    // Mobile skill buttons
    document.querySelectorAll('.mobile-skill-btn').forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const skillIndex = parseInt(btn.dataset.skill);
            if (game.player && !btn.classList.contains('locked') && !btn.classList.contains('on-cooldown')) {
                game.player.useSkill(skillIndex);
                if (navigator.vibrate) navigator.vibrate(40);
            }
        }, { passive: false });
    });
    
    // Update mobile skill buttons UI
    function updateMobileSkillButtons() {
        if (!game.player || !isMobile) return;
        
        document.querySelectorAll('.mobile-skill-btn').forEach(btn => {
            const skillIndex = parseInt(btn.dataset.skill);
            const skill = game.player.skills[skillIndex];
            
            if (!skill) {
                btn.style.display = 'none';
                return;
            }
            
            btn.style.display = 'flex';
            btn.innerHTML = skill.icon;
            
            const locked = skill.unlockLv > game.player.level;
            const onCooldown = skill.cooldownTimer > 0;
            
            btn.classList.toggle('locked', locked);
            btn.classList.toggle('on-cooldown', onCooldown);
            
            // Remove old overlay
            const oldCd = btn.querySelector('.mobile-skill-cd');
            if (oldCd) oldCd.remove();
            
            if (onCooldown) {
                const cdOverlay = document.createElement('div');
                cdOverlay.className = 'mobile-skill-cd';
                cdOverlay.textContent = Math.ceil(skill.cooldownTimer / 60);
                btn.appendChild(cdOverlay);
            }
        });
    }
    
    // Modify player update to use joystick input
    const originalPlayerUpdate = Player.prototype.update;
    Player.prototype.update = function() {
        // Apply joystick input to keys
        if (isMobile && joystickActive) {
            const threshold = 0.3;
            game.input.keys['w'] = joystickVector.y < -threshold;
            game.input.keys['s'] = joystickVector.y > threshold;
            game.input.keys['a'] = joystickVector.x < -threshold;
            game.input.keys['d'] = joystickVector.x > threshold;
            
            // Update angle for mobile
            if (Math.hypot(joystickVector.x, joystickVector.y) > threshold) {
                this.angle = mobileAimAngle;
            }
        } else if (isMobile) {
            // Reset keys when joystick not active
            game.input.keys['w'] = false;
            game.input.keys['s'] = false;
            game.input.keys['a'] = false;
            game.input.keys['d'] = false;
        }
        
        // Call original update
        originalPlayerUpdate.call(this);
    };
    
    // Update mouse position for mobile (use player position + angle)
    const originalScreenToWorld = screenToWorld;
    screenToWorld = function(sx, sy) {
        if (isMobile && game.player) {
            // For mobile, project aim direction from player
            const aimDist = 200;
            return {
                x: game.player.x + Math.cos(mobileAimAngle) * aimDist,
                y: game.player.y + Math.sin(mobileAimAngle) * aimDist
            };
        }
        return originalScreenToWorld(sx, sy);
    };

    // ============= GAME LOOP =============
    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    // Volume control
    document.getElementById('volume-slider').addEventListener('input', (e) => {
        audio.setVolume(e.target.value / 100);
    });
    
    // BGM toggle
    document.getElementById('bgm-toggle').addEventListener('click', (e) => {
        if (audio.bgmPlaying) {
            audio.stopBGM();
            e.target.textContent = 'BGM OFF';
            e.target.style.background = 'rgba(100,100,150,0.5)';
        } else {
            audio.startBGM();
            e.target.textContent = 'BGM ON';
            e.target.style.background = 'rgba(100,200,150,0.5)';
        }
    });
    
    setupMenu();
    loop();
    </script>
</body>
</html>
