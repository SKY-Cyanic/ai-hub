<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>NEON BLOOD : IAI (Remastered)</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Zen+Tokyo+Zoo&display=swap');

    :root {
      --neon-cyan: #00f3ff;
      --neon-pink: #ff0055;
      --neon-lime: #a6ff00;
      --neon-yellow: #ffee00;
      --neon-purple: #bc13fe;
      --neon-white: #ffffff;
      --bg: #050505;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: #fff;
      font-family: 'Rajdhani', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      overflow: hidden;
      touch-action: none;
      user-select: none;
      cursor: crosshair;
    }

    /* Layers */
    #world-layer {
      position: absolute;
      inset: 0;
      z-index: 1;
    }

    #fx-layer {
      position: absolute;
      inset: 0;
      z-index: 2;
      pointer-events: none;
    }

    #ui-layer {
      position: absolute;
      inset: 0;
      z-index: 10;
      pointer-events: none;
    }

    /* Cinematic */
    .scanlines {
      background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.14) 50%, rgba(0, 0, 0, 0.14));
      background-size: 100% 4px;
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: .25;
      z-index: 6;
      mix-blend-mode: overlay;
    }

    .vignette {
      background: radial-gradient(circle at 50% 40%, rgba(0, 0, 0, 0) 45%, rgba(0, 0, 0, 0.88) 100%);
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 5;
    }

    .filmgrain {
      position: fixed;
      inset: 0;
      z-index: 7;
      pointer-events: none;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="260" height="260"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="3" stitchTiles="stitch"/></filter><rect width="260" height="260" filter="url(%23n)" opacity="0.18"/></svg>');
      mix-blend-mode: overlay;
      opacity: .18;
    }

    .cinematic-bar {
      position: fixed;
      left: 0;
      width: 100%;
      height: 0%;
      background: #000;
      z-index: 20;
      transition: height .45s ease;
    }

    .bar-top {
      top: 0;
    }

    .bar-bottom {
      bottom: 0;
    }

    .cinematic-mode .bar-top,
    .cinematic-mode .bar-bottom {
      height: 9%;
    }

    .fatality-mode .bar-top,
    .fatality-mode .bar-bottom {
      height: 16%;
    }

    /* UI */
    .title-font {
      font-family: 'Zen Tokyo Zoo', cursive;
    }

    .hud-text {
      text-shadow: 0 0 10px currentColor;
      letter-spacing: .18em;
    }

    .btn-cyber {
      background: rgba(0, 0, 0, .62);
      border: 1px solid var(--neon-cyan);
      color: var(--neon-cyan);
      text-transform: uppercase;
      letter-spacing: .22em;
      padding: 14px 34px;
      font-weight: 800;
      font-size: 1.05rem;
      position: relative;
      overflow: hidden;
      transition: all .25s ease;
      clip-path: polygon(10% 0, 100% 0, 100% 72%, 90% 100%, 0 100%, 0 30%);
      cursor: pointer;
      pointer-events: auto;
    }

    .btn-cyber:hover {
      background: var(--neon-cyan);
      color: #000;
      box-shadow: 0 0 22px var(--neon-cyan);
    }

    .btn-cyber:active {
      transform: translateY(1px);
    }

    .btn-cyber::before {
      content: '';
      position: absolute;
      top: 0;
      left: -110%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, .35), transparent);
      transition: .55s;
    }

    .btn-cyber:hover::before {
      left: 110%;
    }

    /* Color variants for buttons */
    .btn-cyber.pink {
      border-color: var(--neon-pink);
      color: var(--neon-pink);
    }

    .btn-cyber.pink:hover {
      background: var(--neon-pink);
      color: #000;
      box-shadow: 0 0 22px var(--neon-pink);
    }

    .btn-cyber.lime {
      border-color: var(--neon-lime);
      color: var(--neon-lime);
    }

    .btn-cyber.lime:hover {
      background: var(--neon-lime);
      color: #000;
      box-shadow: 0 0 22px var(--neon-lime);
    }

    .btn-cyber.purple {
      border-color: var(--neon-purple);
      color: var(--neon-purple);
    }

    .btn-cyber.purple:hover {
      background: var(--neon-purple);
      color: #000;
      box-shadow: 0 0 22px var(--neon-purple);
    }

    .health-pip {
      width: 30px;
      height: 10px;
      background: var(--neon-cyan);
      transform: skewX(-20deg);
      box-shadow: 0 0 9px var(--neon-cyan);
      margin-right: 6px;
      transition: .25s;
    }

    .health-pip.lost {
      background: #2b2b2b;
      box-shadow: none;
      width: 12px;
    }

    .meter {
      height: 10px;
      border: 1px solid rgba(255, 255, 255, .18);
      background: rgba(0, 0, 0, .45);
      position: relative;
      overflow: hidden;
      clip-path: polygon(0 0, 96% 0, 100% 50%, 96% 100%, 0 100%);
    }

    .meter>div {
      height: 100%;
      width: 50%;
      background: linear-gradient(90deg, rgba(0, 243, 255, .2), rgba(0, 243, 255, .9));
      box-shadow: 0 0 16px rgba(0, 243, 255, .55);
    }

    .meter-pink>div {
      background: linear-gradient(90deg, rgba(255, 0, 85, .18), rgba(255, 0, 85, .95));
      box-shadow: 0 0 16px rgba(255, 0, 85, .55);
    }

    /* Glitch */
    .glitch {
      position: relative;
    }

    .glitch::before,
    .glitch::after {
      content: attr(data-text);
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
    }

    .glitch::before {
      left: 2px;
      text-shadow: -1px 0 #ff0055;
      clip-path: inset(20% 0 62% 0);
      animation: gl1 4.6s infinite linear alternate-reverse;
      opacity: .9;
    }

    .glitch::after {
      left: -2px;
      text-shadow: 1px 0 #00f3ff;
      clip-path: inset(58% 0 20% 0);
      animation: gl2 5.1s infinite linear alternate-reverse;
      opacity: .85;
    }

    @keyframes gl1 {
      0% {
        clip-path: inset(10% 0 74% 0);
      }

      20% {
        clip-path: inset(50% 0 30% 0);
      }

      40% {
        clip-path: inset(22% 0 58% 0);
      }

      60% {
        clip-path: inset(64% 0 12% 0);
      }

      80% {
        clip-path: inset(30% 0 48% 0);
      }

      100% {
        clip-path: inset(44% 0 30% 0);
      }
    }

    @keyframes gl2 {
      0% {
        clip-path: inset(66% 0 18% 0);
      }

      20% {
        clip-path: inset(18% 0 64% 0);
      }

      40% {
        clip-path: inset(52% 0 26% 0);
      }

      60% {
        clip-path: inset(24% 0 56% 0);
      }

      80% {
        clip-path: inset(12% 0 72% 0);
      }

      100% {
        clip-path: inset(40% 0 38% 0);
      }
    }

    .hidden {
      display: none !important;
    }

    /* Small helper chip */
    .chip {
      border: 1px solid rgba(255, 255, 255, .15);
      background: rgba(0, 0, 0, .45);
      padding: .35rem .6rem;
      letter-spacing: .18em;
      text-transform: uppercase;
    }

    #pause-screen input,
    #pause-screen button {
      pointer-events: auto;
    }

    .color-btn {
      width: 32px;
      height: 32px;
      border: 2px solid #555;
      cursor: pointer;
      transition: 0.2s;
    }

    .color-btn.selected {
      border-color: #fff;
      box-shadow: 0 0 10px #fff;
      transform: scale(1.1);
    }
  </style>
</head>

<body>
  <div class="cinematic-bar bar-top"></div>
  <div class="cinematic-bar bar-bottom"></div>
  <div class="scanlines"></div>
  <div class="vignette"></div>
  <div class="filmgrain"></div>

  <canvas id="world-layer"></canvas>
  <canvas id="fx-layer"></canvas>

  <div id="ui-layer" class="p-5 md:p-6 flex flex-col justify-between">
    <!-- HUD TOP -->
    <div id="hud-top" class="flex items-start justify-between gap-4 hidden">
      <div class="flex flex-col gap-2">
        <div>
          <div class="text-[10px] text-gray-400 tracking-[0.35em]" data-lang="SYNC">SYNCHRONIZATION</div>
          <div class="flex" id="health-container">
            <div class="health-pip"></div>
            <div class="health-pip"></div>
            <div class="health-pip"></div>
          </div>
        </div>

        <div class="w-44 md:w-56">
          <div class="flex items-center justify-between">
            <div class="text-[10px] text-gray-400 tracking-[0.35em]">FOCUS</div>
            <div id="focus-state" class="text-[10px] text-cyan-300 tracking-[0.35em] opacity-70">FREE</div>
          </div>
          <div class="meter">
            <div id="focus-bar"></div>
          </div>
        </div>

        <div class="w-44 md:w-56">
          <div class="flex items-center justify-between">
            <div class="text-[10px] text-gray-400 tracking-[0.35em]">OVERDRIVE</div>
            <div id="od-state" class="text-[10px] text-pink-300 tracking-[0.35em] opacity-70">CHARGE</div>
          </div>
          <div class="meter meter-pink">
            <div id="od-bar" style="width:0%"></div>
          </div>
          <div class="mt-1 text-[9px] tracking-[0.35em] text-white/55" data-lang="OD_HINT">SPACE / DOUBLE TAP</div>
        </div>
      </div>

      <div class="text-center select-none">
        <div class="text-4xl md:text-5xl font-black text-white title-font tracking-widest"
          style="text-shadow:0 0 12px rgba(255,255,255,0.5)">
          <span id="score">0</span>
        </div>
        <div class="text-[10px] text-cyan-300 tracking-[0.55em] mt-1 opacity-75">SCORE</div>
        <div class="mt-2 text-[10px] tracking-[0.35em] text-gray-400">BEST <span id="best"
            class="text-yellow-300 font-bold">0</span></div>
        <div class="mt-1 text-[10px] tracking-[0.35em] text-gray-400">KILLS <span id="kills"
            class="text-white/90 font-bold">0</span></div>
      </div>

      <div class="text-right">
        <div class="chip text-[10px] text-gray-200/80 inline-block" data-lang="PAUSE_HINT">P : PAUSE</div>
        <div class="mt-3">
          <div class="text-[10px] text-gray-400 tracking-[0.35em]">COMBO</div>
          <div class="text-2xl font-extrabold italic text-yellow-300" id="combo-text">x0</div>
          <div class="text-[11px] tracking-[0.35em] text-cyan-300/80">MULTI <span id="mult-text"
              class="text-cyan-200 font-bold">x1</span></div>
        </div>
        <div id="practice-chip" class="mt-3 chip text-[10px] text-white/80 inline-block hidden"
          style="border-color:rgba(255,255,255,.28)" data-lang="PRACTICE">PRACTICE</div>
      </div>
    </div>

    <!-- CENTER MESSAGE -->
    <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center pointer-events-none w-full">
      <div id="message-display" class="transition-all duration-150 opacity-0" style="transform:scale(0.92)">
        <h2 id="message-h2" class="text-5xl md:text-6xl font-black italic text-white glitch" data-text="READY">READY
        </h2>
        <div id="message-sub" class="mt-2 text-[12px] tracking-[0.35em] text-white/70"></div>
      </div>
    </div>

    <!-- BOTTOM HINTS -->
    <div id="bottom-hints"
      class="flex flex-wrap justify-center gap-3 items-center text-[10px] tracking-[0.35em] text-white/65 mb-1 hidden">
      <div class="chip" data-lang="HINT_SWIPE">SWIPE / FLICK</div>
      <div class="chip" data-lang="HINT_MATCH">MATCH THE NEON LINE</div>
      <div class="chip" data-lang="HINT_FOCUS">HOLD STILL = FOCUS</div>
      <div class="chip" data-lang="HINT_OD">SPACE / DOUBLE TAP = OVERDRIVE</div>
    </div>

    <!-- START -->
    <div id="start-screen"
      class="absolute inset-0 flex flex-col items-center justify-center bg-black/80 backdrop-blur-sm pointer-events-auto">
      <div class="text-center px-6">
        <h1 class="text-6xl md:text-8xl title-font text-white mb-2 glitch" data-text="NEON BLOOD">NEON BLOOD</h1>
        <p class="text-cyan-300 tracking-[0.55em] text-xs md:text-sm mb-10">1ST PERSON IAI / NEON TIMING</p>

        <div class="grid grid-cols-2 md:grid-cols-4 gap-3 md:gap-4 mb-10 max-w-4xl">
          <div class="p-4 border border-white/10 bg-black/50">
            <div class="text-xl mb-1">‚Üî</div>
            <div class="text-[10px] text-gray-400" data-lang="HORZ">HORIZONTAL</div>
            <div class="text-cyan-300 font-bold text-sm" data-lang="CUT_HORZ">CUT ‚Üî</div>
          </div>
          <div class="p-4 border border-white/10 bg-black/50">
            <div class="text-xl mb-1">‚Üï</div>
            <div class="text-[10px] text-gray-400" data-lang="VERT">VERTICAL</div>
            <div class="text-pink-400 font-bold text-sm" data-lang="CUT_VERT">CUT ‚Üï</div>
          </div>
          <div class="p-4 border border-white/10 bg-black/50">
            <div class="text-xl mb-1">‚üã</div>
            <div class="text-[10px] text-gray-400" data-lang="DIAG">DIAGONAL</div>
            <div class="text-lime-300 font-bold text-sm" data-lang="CUT_DIAG1">CUT ‚üã</div>
          </div>
          <div class="p-4 border border-white/10 bg-black/50">
            <div class="text-xl mb-1">‚üç</div>
            <div class="text-[10px] text-gray-400" data-lang="DIAG">DIAGONAL</div>
            <div class="text-yellow-300 font-bold text-sm" data-lang="CUT_DIAG2">CUT ‚üç</div>
          </div>
        </div>

        <div class="flex flex-col md:flex-row gap-3 items-center justify-center">
          <button id="start-btn" class="btn-cyber" data-lang="INITIATE">INITIALIZE</button>
          <button id="open-settings-btn" class="btn-cyber" style="border-color:rgba(255,255,255,.55); color:#fff;"
            data-lang="SETTINGS">SETTINGS</button>
        </div>
        <div class="mt-6 text-[11px] tracking-[0.35em] text-white/60" data-lang="TIP_MAIN">TIP: ENEMY FLASHES ‚Üí TIME
          SLOWS ‚Üí CUT THE LIT LINE</div>

        <!-- Premium Shop -->
        <div class="mt-8">
          <button onclick="buyPremiumItem('Unlock All Blades', 100)" class="btn-cyber pink"
            style="padding: 10px 20px; font-size: 0.8rem;">
            üíé UNLOCK ALL BLADES (100 CR)
          </button>
        </div>
      </div>
    </div>

    <!-- PAUSE/SETTINGS -->
    <div id="pause-screen" class="absolute inset-0 hidden pointer-events-auto bg-black/75 backdrop-blur-md">
      <div class="max-w-2xl mx-auto p-6 md:p-10">
        <div class="flex items-center justify-between">
          <h2 class="text-4xl title-font glitch" data-text="SYSTEM">SYSTEM</h2>
          <button id="resume-btn" class="btn-cyber" data-lang="RESUME">RESUME</button>
        </div>

        <div class="mt-8 grid gap-6">

          <!-- New: Language & Color -->
          <div class="flex items-center justify-between">
            <div class="text-xs tracking-[0.35em] text-gray-300" data-lang="LANGUAGE">LANGUAGE</div>
            <button id="toggle-lang" class="btn-cyber py-2 px-4 text-xs"
              style="border-color:rgba(255,255,255,.55); color:#fff;">ENGLISH</button>
          </div>

          <div>
            <div class="text-xs tracking-[0.35em] text-gray-300 mb-2" data-lang="BLADE_COLOR">BLADE COLOR</div>
            <div class="flex gap-3">
              <div class="color-btn selected" style="background:#00f3ff; border-color:#00f3ff;"
                onclick="setBladeColor('cyan')"></div>
              <div class="color-btn" style="background:#ff0055; border-color:#ff0055;" onclick="setBladeColor('pink')">
              </div>
              <div class="color-btn" style="background:#a6ff00; border-color:#a6ff00;" onclick="setBladeColor('lime')">
              </div>
              <div class="color-btn" style="background:#bc13fe; border-color:#bc13fe;"
                onclick="setBladeColor('purple')"></div>
            </div>
          </div>

          <!-- Existing Sliders -->
          <div>
            <div class="flex items-center justify-between mb-2">
              <div class="text-xs tracking-[0.35em] text-gray-300" data-lang="SENSITIVITY">SENSITIVITY</div>
              <div id="sens-val" class="text-xs tracking-[0.35em] text-cyan-200">1.00</div>
            </div>
            <input id="sens" type="range" min="0.6" max="1.8" step="0.01" value="1" class="w-full" />
          </div>

          <div>
            <div class="flex items-center justify-between mb-2">
              <div class="text-xs tracking-[0.35em] text-gray-300" data-lang="TRAIL">TRAIL SIZE</div>
              <div id="trail-val" class="text-xs tracking-[0.35em] text-cyan-200">1.25</div>
            </div>
            <input id="trail" type="range" min="0.8" max="2.7" step="0.01" value="1.25" class="w-full" />
          </div>

          <div>
            <div class="flex items-center justify-between mb-2">
              <div class="text-xs tracking-[0.35em] text-gray-300" data-lang="VOLUME">VOLUME</div>
              <div id="vol-val" class="text-xs tracking-[0.35em] text-cyan-200">0.80</div>
            </div>
            <input id="vol" type="range" min="0" max="1" step="0.01" value="0.8" class="w-full" />
          </div>

          <div class="flex flex-col md:flex-row gap-3 flex-wrap">
            <button id="toggle-shake" class="btn-cyber" style="border-color:rgba(255,255,255,.55); color:#fff;"
              data-lang="BTN_SHAKE">SHAKE: ON</button>
            <button id="toggle-rain" class="btn-cyber" style="border-color:rgba(255,255,255,.55); color:#fff;"
              data-lang="BTN_RAIN">RAIN: ON</button>
            <button id="toggle-free" class="btn-cyber" style="border-color:rgba(255,255,255,.55); color:#fff;"
              data-lang="BTN_FREE">FREE MOUSE: ON</button>
            <button id="toggle-practice" class="btn-cyber" style="border-color:rgba(255,255,255,.55); color:#fff;"
              data-lang="BTN_PRACTICE">PRACTICE: OFF</button>
          </div>

          <div class="flex flex-col md:flex-row gap-3 flex-wrap">
            <button id="toggle-music" class="btn-cyber" style="border-color:rgba(255,255,255,.55); color:#fff;"
              data-lang="BTN_MUSIC">MUSIC: ON</button>
            <button id="toggle-rhythm" class="btn-cyber" style="border-color:rgba(255,255,255,.55); color:#fff;"
              data-lang="BTN_RHYTHM">RHYTHM SYNC: OFF</button>
            <button id="toggle-metro" class="btn-cyber" style="border-color:rgba(255,255,255,.55); color:#fff;"
              data-lang="BTN_METRO">METRONOME: ON</button>
          </div>

          <div class="text-[11px] tracking-[0.35em] text-white/60 leading-relaxed" id="rules-text">
            - PC: FLICK MOUSE (Free Mouse ON Recommended) / SPACE: OVERDRIVE<br />
            - MOBILE: SWIPE/FLICK. DOUBLE TAP: OVERDRIVE<br />
            - VERY FAST WRONG INPUT = PARRY (RESET)<br />
            - PRACTICE = NO DAMAGE
          </div>
        </div>
      </div>
    </div>

    <!-- GAME OVER -->
    <div id="game-over-screen"
      class="absolute inset-0 hidden pointer-events-auto bg-red-950/80 backdrop-blur-md flex items-center justify-center">
      <div class="text-center px-6">
        <h2 class="text-6xl md:text-7xl font-black text-white mb-4 glitch" data-text="CRITICAL">CRITICAL</h2>
        <div class="text-2xl text-white mb-3 tracking-widest">SCORE: <span id="final-score"
            class="text-yellow-300 font-black">0</span></div>
        <div class="text-sm tracking-[0.35em] text-white/70 mb-8">BEST: <span id="final-best"
            class="text-cyan-200 font-bold">0</span></div>
        <div class="flex flex-col md:flex-row gap-3 justify-center">
          <button id="restart-btn" class="btn-cyber border-white text-white hover:bg-white hover:text-black"
            data-lang="REBOOT">REBOOT</button>
          <button id="copy-score-btn" class="btn-cyber" style="border-color:rgba(255,255,255,.55); color:#fff;"
            data-lang="COPY">COPY RESULT</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ==========================================================
    // NEON BLOOD : REMASTERED + NEW FEATURES
    // Added: Language, Blade Color, Ghost Enemy, Second Wind
    // ==========================================================

    const world = document.getElementById('world-layer');
    const fx = document.getElementById('fx-layer');
    const ctx = world.getContext('2d', { alpha: false });
    const fxCtx = fx.getContext('2d');

    let W = 0, H = 0, DPR = 1;

    const STATE = { MENU: 0, PLAY: 1, PAUSE: 2, OVER: 3 };
    let state = STATE.MENU;

    const LS_BEST = 'neonblood_best_v2';
    let bestScore = Number(localStorage.getItem(LS_BEST) || '0');
    document.getElementById('best').innerText = bestScore;

    // LANGUAGE DATA
    const LANG = {
      EN: {
        SYNC: "SYNCHRONIZATION",
        OD_HINT: "SPACE / DOUBLE TAP",
        PAUSE_HINT: "P : PAUSE",
        PRACTICE: "PRACTICE",
        HINT_SWIPE: "SWIPE / FLICK",
        HINT_MATCH: "MATCH THE NEON LINE",
        HINT_FOCUS: "HOLD STILL = FOCUS",
        HINT_OD: "SPACE / DOUBLE TAP = OVERDRIVE",
        INITIATE: "INITIATE",
        SETTINGS: "SETTINGS",
        HORZ: "HORIZONTAL",
        VERT: "VERTICAL",
        DIAG: "DIAGONAL",
        CUT_HORZ: "CUT ‚Üî",
        CUT_VERT: "CUT ‚Üï",
        CUT_DIAG1: "CUT ‚üã",
        CUT_DIAG2: "CUT ‚üç",
        TIP_MAIN: "TIP: ENEMY FLASHES ‚Üí TIME SLOWS ‚Üí CUT THE LIT LINE",
        RESUME: "RESUME",
        LANGUAGE: "LANGUAGE",
        BLADE_COLOR: "BLADE COLOR",
        SENSITIVITY: "SENSITIVITY",
        TRAIL: "TRAIL SIZE",
        VOLUME: "VOLUME",
        BTN_SHAKE: "SHAKE",
        BTN_RAIN: "RAIN",
        BTN_FREE: "FREE MOUSE",
        BTN_PRACTICE: "PRACTICE",
        BTN_MUSIC: "MUSIC",
        BTN_RHYTHM: "RHYTHM SYNC",
        BTN_METRO: "METRONOME",
        RULES: "- PC: FLICK MOUSE / SPACE: OVERDRIVE<br/>- MOBILE: SWIPE. DOUBLE TAP: OVERDRIVE<br/>- FAST WRONG INPUT = PARRY<br/>- GHOST ENEMY = FLICKERS<br/>- RHYTHM SYNC: CUT ON THE BEAT FOR BONUS",
        REBOOT: "REBOOT",
        COPY: "COPY RESULT",
        MSG_READY: "READY",
        MSG_SCAN: "SCANNING",
        MSG_LISTEN: "LISTEN TO THE RAIN",
        MSG_PAUSED: "PAUSED",
        MSG_RESUME: "RESUME",
        MSG_OVER: "SYSTEM DOWN",
        MSG_REBOOT: "REBOOT?",
        MSG_PARRY: "PARRY",
        MSG_RESET: "RESET",
        MSG_DEFLECT: "DEFLECT",
        MSG_WRONG: "WRONG ANGLE",
        MSG_RESTORED: "SYSTEM RESTORED",
        MSG_SECOND_WIND: "SECOND WIND",
        MSG_BOSS: "BOSS INCOMING",
        MSG_CHAIN: "CHAIN SLASH",
        MSG_FATALITY: "FATALITY",
        ON: "ON",
        OFF: "OFF"
      },
      KO: {
        SYNC: "ÎèôÍ∏∞ÌôîÏú®",
        OD_HINT: "SPACE / ÎçîÎ∏îÌÉ≠",
        PAUSE_HINT: "P : ÏùºÏãúÏ†ïÏßÄ",
        PRACTICE: "Ïó∞Ïäµ Î™®Îìú",
        HINT_SWIPE: "Îπ†Î•¥Í≤å Í∏ãÍ∏∞",
        HINT_MATCH: "ÎπõÎÇòÎäî ÏÑ†ÏùÑ Î≤†Îùº",
        HINT_FOCUS: "Î©àÏ∂§ = ÏßëÏ§ë",
        HINT_OD: "SPACE / ÎçîÎ∏îÌÉ≠ = Ïò§Î≤ÑÎìúÎùºÏù¥Î∏å",
        INITIATE: "ÏãúÏä§ÌÖú Í∞ÄÎèô",
        SETTINGS: "ÏÑ§Ï†ï",
        HORZ: "Í∞ÄÎ°ú",
        VERT: "ÏÑ∏Î°ú",
        DIAG: "ÎåÄÍ∞ÅÏÑ†",
        CUT_HORZ: "Í∞ÄÎ°ú Î≤†Í∏∞ ‚Üî",
        CUT_VERT: "ÏÑ∏Î°ú Î≤†Í∏∞ ‚Üï",
        CUT_DIAG1: "ÎåÄÍ∞Å Î≤†Í∏∞ ‚üã",
        CUT_DIAG2: "ÎåÄÍ∞Å Î≤†Í∏∞ ‚üç",
        TIP_MAIN: "ÌåÅ: Ï†ÅÏù¥ Î≤àÏ©çÏù¥Î©¥ ÏãúÍ∞ÑÏù¥ ÎäêÎ†§ÏßëÎãàÎã§. ÎπõÎÇòÎäî ÏÑ†ÏùÑ Î≤†ÏÑ∏Ïöî.",
        RESUME: "Í≥ÑÏÜçÌïòÍ∏∞",
        LANGUAGE: "Ïñ∏Ïñ¥ (LANGUAGE)",
        BLADE_COLOR: "Í≤Ä ÏÉâÏÉÅ",
        SENSITIVITY: "ÎØºÍ∞êÎèÑ",
        TRAIL: "Í∂§Ï†Å ÌÅ¨Í∏∞",
        VOLUME: "Î≥ºÎ•®",
        BTN_SHAKE: "ÌôîÎ©¥ ÌùîÎì§Î¶º",
        BTN_RAIN: "ÎπÑ Ìö®Í≥º",
        BTN_FREE: "ÏûêÏú† ÎßàÏö∞Ïä§",
        BTN_PRACTICE: "Ïó∞Ïäµ Î™®Îìú",
        BTN_MUSIC: "ÏùåÏïÖ",
        BTN_RHYTHM: "Î¶¨Îì¨ ÎèôÍ∏∞Ìôî",
        BTN_METRO: "Î©îÌä∏Î°úÎÜà",
        RULES: "- PC: ÎßàÏö∞Ïä§Î•º Îπ†Î•¥Í≤å Í∏ãÍ∏∞ / SPACE: Ïò§Î≤ÑÎìúÎùºÏù¥Î∏å<br/>- Î™®Î∞îÏùº: Ïä§ÏôÄÏù¥ÌîÑ / ÎçîÎ∏îÌÉ≠: Ïò§Î≤ÑÎìúÎùºÏù¥Î∏å<br/>- Î≤àÏ©ç ÏßÅÌõÑ Îπ†Î•∏ Ïò§ÎãµÏùÄ Ìå®ÎßÅ(Î∞©Ïñ¥)Îê©ÎãàÎã§.<br/>- Í≥†Ïä§Ìä∏ Ï†ÅÏùÄ Î™®ÏäµÏù¥ ÍπúÎπ°ÏûÖÎãàÎã§.<br/>- Î¶¨Îì¨ ÎèôÍ∏∞Ìôî: ÎπÑÌä∏ ÌÉÄÏù¥Î∞çÏóê Î≤†Î©¥ Î≥¥ÎÑàÏä§",
        REBOOT: "Ïû¨Í∞ÄÎèô",
        COPY: "Í≤∞Í≥º Î≥µÏÇ¨",
        MSG_READY: "Ï§ÄÎπÑ",
        MSG_SCAN: "Ïä§Ï∫î Ï§ë...",
        MSG_LISTEN: "ÎπóÏÜåÎ¶¨Ïóê ÏßëÏ§ëÌïòÎùº",
        MSG_PAUSED: "ÏùºÏãúÏ†ïÏßÄ",
        MSG_RESUME: "Ïû¨Í∞ú",
        MSG_OVER: "ÏãúÏä§ÌÖú Ï¢ÖÎ£å",
        MSG_REBOOT: "Ïû¨Î∂ÄÌåÖ ÌïÑÏöî",
        MSG_PARRY: "Ìå®ÎßÅ",
        MSG_RESET: "ÏûêÏÑ∏ Î≥µÍµ¨",
        MSG_DEFLECT: "ÌäïÍ≤®ÎÉÑ",
        MSG_WRONG: "Î∞©Ìñ• Ïò§Î•ò",
        MSG_RESTORED: "ÏãúÏä§ÌÖú Î≥µÍµ¨",
        MSG_SECOND_WIND: "Í∏¥Í∏â Î∂ÄÌôú",
        MSG_BOSS: "Î≥¥Ïä§ Ï∂úÌòÑ",
        MSG_CHAIN: "Ïó∞ÏÜç Î≤†Í∏∞",
        MSG_FATALITY: "Ï≤òÌòï",
        ON: "ÏºúÏßê",
        OFF: "Í∫ºÏßê"
      }
    };

    const config = {
      lang: 'EN', // 'EN' or 'KO'
      bladeColor: 'cyan', // cyan, pink, lime, purple
      sensitivity: 1.0,
      trailScale: 1.25,
      volume: 0.8,
      screenShake: 1.0,
      rain: true,
      freeMouse: true,
      practice: false,

      // NEW: Rhythm / Music
      music: true,
      rhythmSync: false,   // on-beat bonus scoring
      metronome: true,     // audible tick
    };

    function t(key) { return LANG[config.lang][key] || key; }

    function updateText() {
      document.querySelectorAll('[data-lang]').forEach(el => {
        const key = el.getAttribute('data-lang');
        if (key.startsWith('BTN_')) {
          // Special handling for toggle buttons
          const base = t(key);
          let status = '';
          if (key === 'BTN_SHAKE') status = config.screenShake > 0 ? t('ON') : t('OFF');
          if (key === 'BTN_RAIN') status = config.rain ? t('ON') : t('OFF');
          if (key === 'BTN_FREE') status = config.freeMouse ? t('ON') : t('OFF');
          if (key === 'BTN_PRACTICE') status = config.practice ? t('ON') : t('OFF');
          if (key === 'BTN_MUSIC') status = config.music ? t('ON') : t('OFF');
          if (key === 'BTN_RHYTHM') status = config.rhythmSync ? t('ON') : t('OFF');
          if (key === 'BTN_METRO') status = config.metronome ? t('ON') : t('OFF');
          el.innerText = `${base}: ${status}`;
        } else {
          el.innerText = t(key);
        }
      });
      document.getElementById('rules-text').innerHTML = t('RULES');
      document.getElementById('toggle-lang').innerText = config.lang === 'EN' ? 'ENGLISH' : 'ÌïúÍµ≠Ïñ¥';
    }

    // HUD refs
    const hudTop = document.getElementById('hud-top');
    const bottomHints = document.getElementById('bottom-hints');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const killsEl = document.getElementById('kills');
    const comboEl = document.getElementById('combo-text');
    const multEl = document.getElementById('mult-text');
    const focusBarEl = document.getElementById('focus-bar');
    const focusStateEl = document.getElementById('focus-state');
    const odBarEl = document.getElementById('od-bar');
    const odStateEl = document.getElementById('od-state');
    const practiceChipEl = document.getElementById('practice-chip');

    // Message
    const msgWrap = document.getElementById('message-display');
    const msgH2 = document.getElementById('message-h2');
    const msgSub = document.getElementById('message-sub');
    let msgTimer = 0;

    // Game vars
    let score = 0;
    let killsTotal = 0;
    let combo = 0;
    let comboTimer = 0;
    let health = 3;
    let focus = 1.0;
    let lastTime = 0;

    let overdrive = 0;
    let overdriveActive = 0;
    let spawnBossNext = false;
    let fatalityT = 0;
    let lastTapTime = 0;

    // Camera
    const cam = {
      shake: 0,
      zoom: 1,
      zoomTarget: 1,
      offsetX: 0,
      offsetY: 0,
      dashT: 0,
      dashDX: 0,
      dashDY: 0,
      flash: 0,
      redFlash: 0,
      lightning: 0,
      odTint: 0,
    };

    let hitStop = 0;
    let enemies = [];
    let dead = [];
    let particles = [];
    let raindrops = [];
    let spawnCooldown = 0;
    let intensity = 0;

    // Audio
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    const audio = {
      master: null,
      rain: null,
      rainGain: null,

      // beat clock
      beatT: 0,
      beatStep: 0,
      bpm: 70,
      beatPulse: 0,

      // music
      musicT: 0,
      musicStep: 0,
      chordStep: 0,
      key: 45, // A1 base midi-ish
      lastBeatAt: 0,
    };

    function ensureAudio() {
      if (audioCtx) return;
      audioCtx = new AudioContext();
      audio.master = audioCtx.createGain();
      audio.master.gain.value = config.volume;
      audio.master.connect(audioCtx.destination);

      // Rain Noise
      const bufferSize = 2 * audioCtx.sampleRate;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const out = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) out[i] = (Math.random() * 2 - 1) * 0.5;
      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuffer;
      noise.loop = true;

      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 900;
      bp.Q.value = 0.8;
      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.value = 2200;
      const g = audioCtx.createGain();
      g.gain.value = 0.05; // Reduced rain volume significantly

      noise.connect(bp); bp.connect(lp); lp.connect(g); g.connect(audio.master);
      noise.start();
      audio.rain = noise;
      audio.rainGain = g;
    }

    function setVolume(v) {
      config.volume = v;
      if (audio.master) audio.master.gain.value = v;
    }

    function tone(type, dur, f0, f1, vol, when = 0) {
      if (!audioCtx) return;
      const t = audioCtx.currentTime + when;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(f0, t);
      if (f1 && f1 !== f0) osc.frequency.exponentialRampToValueAtTime(Math.max(1, f1), t + dur);
      g.gain.setValueAtTime(vol, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
      osc.connect(g); g.connect(audio.master);
      osc.start(t);
      osc.stop(t + dur);
    }

    function noiseHit(dur, vol, when = 0) {
      if (!audioCtx) return;
      const t = audioCtx.currentTime + when;
      const bs = Math.max(256, Math.floor(audioCtx.sampleRate * dur));
      const b = audioCtx.createBuffer(1, bs, audioCtx.sampleRate);
      const data = b.getChannelData(0);
      for (let i = 0; i < bs; i++) data[i] = (Math.random() * 2 - 1);
      const src = audioCtx.createBufferSource();
      src.buffer = b;
      const hp = audioCtx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 1200;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(vol, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
      src.connect(hp); hp.connect(g); g.connect(audio.master);
      src.start(t);
      src.stop(t + dur);
    }

    const SFX = {
      whoosh(s = 1) { noiseHit(0.08, 0.08 * s); tone('sine', 0.06, 240, 90, 0.10 * s); },
      flash() { tone('square', 0.05, 1600, 800, 0.12); },
      slash() { tone('sawtooth', 0.09, 160, 70, 0.25); noiseHit(0.06, 0.16); },
      metal() { tone('triangle', 0.06, 2100, 1200, 0.12); tone('square', 0.04, 3400, 1800, 0.05); },
      shatter() { noiseHit(0.12, 0.22); tone('sine', 0.12, 120, 60, 0.22); tone('triangle', 0.06, 2800, 900, 0.10); },
      sheath() { tone('triangle', 0.08, 520, 240, 0.18); },
      hit() { tone('sawtooth', 0.12, 120, 60, 0.22); tone('sine', 0.08, 80, 40, 0.25); },
      thunder() { tone('sine', 0.6, 55, 30, 0.18); noiseHit(0.5, 0.10); },
      overdrive() { tone('sawtooth', 0.18, 220, 70, 0.22); tone('square', 0.12, 1200, 500, 0.08); noiseHit(0.10, 0.10); },
      tick() { tone('square', 0.02, 2600, 1800, 0.05); },
      onBeat() { tone('triangle', 0.06, 900, 420, 0.10); }
    };

    function mtof(m) { return 440 * Math.pow(2, (m - 69) / 12); }

    function playMusicStep(step, intensity01) {
      if (!audioCtx) return;
      if (!config.music) return;

      // TECHNO PATTERNS (16 steps)
      const KICK = [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0];
      const SNARE = [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0];
      const OHAT = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0];
      const CHAT = [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1];
      const BASS = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0]; // Off-beat bass

      const t = audioCtx.currentTime;
      const key = audio.key; // Base note (F or G usually good for techno)
      const volMult = 0.5 + 0.5 * intensity01;

      // Kick (Strong Sine Drop)
      if (KICK[step]) {
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.2);
        g.gain.setValueAtTime(0.5 * volMult, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
        osc.connect(g); g.connect(audio.master);
        osc.start(t); osc.stop(t + 0.25);

        // Click for kick
        noiseHit(0.01, 0.1 * volMult);
      }

      // Snare (Noise + Tone)
      if (SNARE[step]) {
        noiseHit(0.12, 0.15 * volMult);
        tone('triangle', 0.05, 180, 120, 0.1 * volMult);
      }

      // Hi-Hats
      if (OHAT[step]) {
        // Open Hat
        noiseHit(0.1, 0.08 * volMult);
      } else if (CHAT[step]) {
        // Closed Hat
        noiseHit(0.03, 0.04 * volMult);
      }

      // Rolling Bass (Sawtooth Lowpass)
      if (BASS[step] || (intensity01 > 0.5 && step % 2 === 0)) {
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        const f = audioCtx.createBiquadFilter();
        osc.type = 'sawtooth';
        osc.frequency.value = mtof(key - 24); // Low bass
        f.type = 'lowpass';
        f.frequency.setValueAtTime(400 + intensity01 * 800, t);
        f.Q.value = 5;
        g.gain.setValueAtTime(0.15 * volMult, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
        osc.connect(f); f.connect(g); g.connect(audio.master);
        osc.start(t); osc.stop(t + 0.2);
      }

      // Arp / Melody (High intensity only)
      if (intensity01 > 0.3 && step % 4 === 0) {
        const notes = [0, 3, 7, 10, 12];
        const n = notes[Math.floor(Math.random() * notes.length)];
        tone('square', 0.1, mtof(key + n), mtof(key + n), 0.03 * volMult);
      }
    }

    function scheduleBeat(dt) {
      if (!audioCtx || state !== STATE.PLAY) return;

      // BPM follows combo & overdrive
      const odBoost = overdriveActive > 0 ? 22 : 0;
      const targetBpm = 70 + Math.min(80, combo * 2.2) + odBoost;
      audio.bpm += (targetBpm - audio.bpm) * 0.02;
      const spb = 60 / audio.bpm;      // seconds per beat
      const sp16 = spb / 2;            // 8th note for heartbeat
      const sp32 = spb / 4;            // 16th note for music

      // Pulse decay for visuals (Audio Reactivity)
      audio.beatPulse = Math.max(0, audio.beatPulse - dt * 4.0);

      // Music Timing Logic
      audio.beatT += dt;
      audio.musicT += dt;

      const intensity01 = Math.min(1, combo / 15) + (overdriveActive > 0 ? 0.3 : 0);

      // 16th Note Clock (Music Sequencer)
      while (audio.musicT >= sp32) {
        audio.musicT -= sp32;
        audio.musicStep = (audio.musicStep + 1) % 16;

        // Trigger Music Sequencer
        playMusicStep(audio.musicStep, intensity01);

        // On Quarter Note (Kick)
        if (audio.musicStep % 4 === 0) {
          audio.lastBeatAt = performance.now();
          audio.beatPulse = 1.0; // Visual Pulse Trigger
          if (config.metronome) SFX.tick();

          // RHYTHM SPAWNING LOGIC
          // Spawn enemies on the first beat of a bar (every 16 steps) or half-bar
          const barStart = (audio.musicStep === 0);
          const halfBar = (audio.musicStep === 8);

          // Spawn Logic integrated with Beat
          if (state === STATE.PLAY && spawnCooldown <= 0) {
            // Higher intensity = spawn more often (every half bar)
            const canSpawn = barStart || (intensity > 5 && halfBar);

            if (canSpawn) {
              const maxEnemies = Math.min(3, 1 + Math.floor(intensity / 6));
              if (enemies.length < maxEnemies) {
                if (spawnBossNext) { spawnEnemy(ENEMY_KIND.BOSS); spawnBossNext = false; }
                else spawnEnemy();
                // Cooldown is now roughly related to bars
                spawnCooldown = 0.1;
              }
            }
          }
        }
      }
    }

    // Input
    const input = { x: 0, y: 0, active: false, mouseDown: false, points: [], angle: 0, velocity: 0, holdTime: 0, focusMode: false };

    function addPoint(x, y) {
      const now = performance.now();
      input.points.push({ x, y, t: now });
      while (input.points.length && now - input.points[0].t > 190) input.points.shift();
    }

    function computeMotion() {
      if (input.points.length < 2) return;
      const a = input.points[0];
      const b = input.points[input.points.length - 1];
      const dt = Math.max(1, (b.t - a.t));
      const dist = Math.hypot(b.x - a.x, b.y - a.y);
      input.velocity = (dist / dt) * config.sensitivity;
      if (dist > 6) input.angle = Math.atan2(b.y - a.y, b.x - a.x);
    }

    function updatePointer(x, y, active) {
      input.x = x; input.y = y; input.active = active;
      addPoint(x, y); computeMotion();
    }

    function tryActivateOverdrive() {
      if (state !== STATE.PLAY) return;
      if (overdriveActive > 0) return;
      if (overdrive < 0.999) return;
      overdriveActive = 5.5;
      overdrive = 1;
      cam.flash = Math.max(cam.flash, 0.55);
      cam.shake = Math.max(cam.shake, 14);
      cam.lightning = Math.max(cam.lightning, 0.35);
      showMessage('OVERDRIVE', 'rgba(255,0,85,1)', 'SLOW TIME / EXTRA MULTI');
      SFX.overdrive();
      if (navigator.vibrate) navigator.vibrate([25, 20, 50, 20, 25]);
    }

    window.addEventListener('pointerdown', (e) => {
      if (e.pointerType === 'mouse') input.mouseDown = true;
      input.points = []; input.holdTime = 0;
      ensureAudio();
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      if (e.pointerType !== 'mouse' && state === STATE.PLAY) {
        const now = performance.now();
        if (now - lastTapTime < 260) tryActivateOverdrive();
        lastTapTime = now;
      }
      updatePointer(e.clientX, e.clientY, true);
    }, { passive: false });

    window.addEventListener('pointermove', (e) => {
      e.preventDefault();
      const allow = (e.pointerType !== 'mouse') ? true : (config.freeMouse ? true : input.mouseDown);
      updatePointer(e.clientX, e.clientY, allow);
    }, { passive: false });

    window.addEventListener('pointerup', (e) => {
      if (e.pointerType === 'mouse') input.mouseDown = false;
      input.active = false; input.holdTime = 0; input.focusMode = false;
    }, { passive: true });

    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'p') {
        if (state === STATE.PLAY) pause();
        else if (state === STATE.PAUSE) resume();
      }
      if (e.code === 'Space') { e.preventDefault(); tryActivateOverdrive(); }
      if (e.key === 'Escape' && state === STATE.PLAY) pause();
    });

    const DIR = { HORZ: 'HORZ', VERT: 'VERT', DIAG1: 'DIAG1', DIAG2: 'DIAG2' };
    const ENEMY_KIND = { ONI: 'ONI', DRONE: 'DRONE', SHIELD: 'SHIELD', BOSS: 'BOSS', GHOST: 'GHOST' };

    function dirFromAngle(rad) {
      let deg = rad * 180 / Math.PI;
      if (deg < 0) deg += 360;
      const w = 28;
      const near = (a, b) => Math.abs(((a - b + 540) % 360) - 180) <= w;
      if (near(deg, 0) || near(deg, 180)) return DIR.HORZ;
      if (near(deg, 90) || near(deg, 270)) return DIR.VERT;
      if (near(deg, 45) || near(deg, 225)) return DIR.DIAG1;
      if (near(deg, 135) || near(deg, 315)) return DIR.DIAG2;
      return null;
    }

    function randomWeakDir() {
      const r = Math.random();
      if (r < 0.33) return DIR.HORZ;
      if (r < 0.66) return DIR.VERT;
      return Math.random() < 0.5 ? DIR.DIAG1 : DIR.DIAG2;
    }

    function weakColor(dir) {
      switch (dir) {
        case DIR.HORZ: return 'rgba(0,243,255,1)';
        case DIR.VERT: return 'rgba(255,0,85,1)';
        case DIR.DIAG1: return 'rgba(166,255,0,1)';
        case DIR.DIAG2: return 'rgba(255,238,0,1)';
      }
      return 'rgba(255,255,255,1)';
    }

    function spawnEnemy(kind = null) {
      // NEW: GHOST ENEMY chance
      let k = kind;
      if (!k) {
        if (intensity < 6) k = ENEMY_KIND.ONI;
        else {
          const r = Math.random();
          if (r < 0.50) k = ENEMY_KIND.ONI;
          else if (r < 0.70) k = ENEMY_KIND.DRONE;
          else if (r < 0.85) k = ENEMY_KIND.SHIELD;
          else k = ENEMY_KIND.GHOST;
        }
      }

      const baseZ = (k === ENEMY_KIND.BOSS) ? (3200 + Math.random() * 350) : (2600 + Math.random() * 500);
      let weak = randomWeakDir();
      let col = weakColor(weak);
      // Ghost is purple/white
      if (k === ENEMY_KIND.GHOST) col = 'rgba(188,19,254,1)';

      const e = {
        kind: k,
        weak,
        neon: col,
        x: (Math.random() * 2 - 1) * 260,
        y: (Math.random() * 2 - 1) * 120,
        z: baseZ,
        state: 'APPROACH',
        t: 0,
        react: 0.75,
        flashAt: 0,
        hp: (k === ENEMY_KIND.SHIELD) ? 2 : 1,
        seed: Math.random() * 9999,
        seq: null,
        step: 0,
        flicker: 1.0 // for ghost
      };

      if (k === ENEMY_KIND.BOSS) {
        e.x = (Math.random() * 2 - 1) * 90;
        e.y = (Math.random() * 2 - 1) * 55;
        e.seq = [randomWeakDir(), randomWeakDir(), randomWeakDir()];
        for (let i = 1; i < e.seq.length; i++) {
          if (e.seq[i] === e.seq[i - 1]) e.seq[i] = randomWeakDir();
        }
        e.hp = e.seq.length;
        e.step = 0;
        e.weak = e.seq[0];
        e.neon = 'rgba(255,0,85,1)';
      }
      enemies.push(e);
    }

    function enemyProjection(e) {
      const cx = W / 2, cy = H / 2, z = Math.max(150, e.z), fov = 980;
      const scale = fov / z;
      const sx = cx + e.x * scale;
      const sy = cy + e.y * scale;
      const baseSize = (e.kind === ENEMY_KIND.BOSS) ? 260 : 180;
      const size = Math.max(32, baseSize * scale);
      return { sx, sy, scale, size, z };
    }

    function burst(x, y, color, n = 18, type = 'spark') {
      for (let i = 0; i < n; i++) {
        const a = Math.random() * Math.PI * 2;
        const sp = (type === 'blood' ? 8 + Math.random() * 18 : 7 + Math.random() * 14);
        particles.push({
          x, y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - (type === 'blood' ? 2 : 0),
          life: 0.9 + Math.random() * 0.4, color, type,
          size: (type === 'shard' ? 3 + Math.random() * 7 : 1.5 + Math.random() * 4),
          rot: Math.random() * Math.PI, vr: (Math.random() * 2 - 1) * 0.25
        });
      }
    }

    function bloodStreak(x, y, color) {
      burst(x, y, color, 30, 'blood');
      burst(x, y, 'rgba(255,255,255,0.9)', 12, 'spark');
      burst(x, y, color, 22, 'shard');
    }

    function initRain() {
      raindrops = [];
      const count = Math.min(240, Math.floor((W * H) / 8500));
      for (let i = 0; i < count; i++) {
        raindrops.push({ x: Math.random() * W, y: Math.random() * H, z: Math.random(), len: 8 + Math.random() * 22, sp: 280 + Math.random() * 520 });
      }
    }

    function resetRun() {
      score = 0; killsTotal = 0; combo = 0; comboTimer = 0; health = 3; focus = 1.0;
      intensity = 0; spawnCooldown = 0; enemies = []; dead = []; particles = [];
      cam.shake = 0; cam.zoom = 1; cam.zoomTarget = 1; cam.flash = 0; cam.redFlash = 0; cam.lightning = 0;
      hitStop = 0; overdrive = 0; overdriveActive = 0; spawnBossNext = false; fatalityT = 0;
      document.body.classList.remove('fatality-mode');
      updateHUD(); initRain();
    }

    function updateHUD() {
      updateText(); // ensure translation is active
      scoreEl.innerText = String(score);
      killsEl.innerText = String(killsTotal);
      comboEl.innerText = 'x' + combo;
      const mult = 1 + Math.floor(combo / 5) + (overdriveActive > 0 ? 1 : 0);
      multEl.innerText = 'x' + mult;
      bestEl.innerText = bestScore;

      const pips = document.querySelectorAll('.health-pip');
      pips.forEach((pip, i) => {
        if (i < health) pip.classList.remove('lost');
        else pip.classList.add('lost');
      });

      focusBarEl.style.width = Math.max(0, Math.min(1, focus)) * 100 + '%';
      odBarEl.style.width = Math.max(0, Math.min(1, overdrive)) * 100 + '%';

      if (overdriveActive > 0) odStateEl.innerText = 'ACTIVE';
      else odStateEl.innerText = (overdrive >= 0.999 ? 'READY' : 'CHARGE');

      practiceChipEl.classList.toggle('hidden', !config.practice);
    }

    function showMessage(text, color = '#fff', sub = '') {
      msgH2.innerText = text;
      msgH2.setAttribute('data-text', text);
      msgH2.style.color = color;
      msgSub.innerText = sub;
      msgWrap.style.opacity = '1';
      msgWrap.style.transform = 'scale(1.14)';
      msgTimer = 0.55;
    }

    function pause() {
      if (state !== STATE.PLAY) return;
      state = STATE.PAUSE;
      document.getElementById('pause-screen').classList.remove('hidden');
      showMessage(t('MSG_PAUSED'), 'rgba(255,255,255,0.95)', t('PAUSE_HINT'));
    }

    function resume() {
      if (state !== STATE.PAUSE) return;
      state = STATE.PLAY;
      document.getElementById('pause-screen').classList.add('hidden');
      showMessage(t('MSG_RESUME'), 'rgba(0,243,255,1)', '');
    }

    function trailHits(sx, sy, r) {
      for (let i = input.points.length - 1; i >= 0; i--) {
        const p = input.points[i];
        if (Math.hypot(p.x - sx, p.y - sy) <= r) return true;
      }
      return false;
    }

    function trySlash(enemy) {
      const dir = dirFromAngle(input.angle);
      if (!dir) return false;
      const energy = input.velocity;
      if (input.points.length < 3) return false;
      const a = input.points[0];
      const b = input.points[input.points.length - 1];
      if (energy < 0.85 || Math.hypot(b.x - a.x, b.y - a.y) < 70) return false;

      const { sx, sy, size } = enemyProjection(enemy);
      if (!trailHits(sx, sy, size * 0.62)) return false;

      SFX.slash();
      const targetWeak = (enemy.kind === ENEMY_KIND.BOSS && enemy.seq) ? enemy.seq[enemy.step] : enemy.weak;

      if (dir === targetWeak) {
        enemy.hp -= 1;
        if (enemy.kind === ENEMY_KIND.BOSS && enemy.seq) {
          enemy.step += 1;
          if (enemy.hp <= 0) killEnemy(enemy, dir);
          else {
            enemy.weak = enemy.seq[enemy.step];
            cam.shake = Math.max(cam.shake, 12 * config.screenShake);
            burst(sx, sy, enemy.neon, 16, 'spark');
            showMessage(t('MSG_CHAIN'), enemy.neon, `${enemy.hp} LEFT`);
            SFX.metal();
            if (navigator.vibrate) navigator.vibrate(25);
            enemy.state = 'TELEGRAPH';
            enemy.t = 0;
            enemy.flashAt = performance.now();
            SFX.flash();
          }
          return true;
        }

        if (enemy.hp <= 0) killEnemy(enemy, dir);
        else {
          cam.shake = Math.max(cam.shake, 10);
          burst(sx, sy, enemy.neon, 14, 'spark');
          burst(sx, sy, 'rgba(255,255,255,0.9)', 10, 'shard');
          showMessage('CRACK', enemy.neon, 'ONE MORE CUT');
          enemy.t += 0.12;
          SFX.metal();
          if (navigator.vibrate) navigator.vibrate(30);
        }
        return true;
      } else {
        const now = performance.now();
        const rt = enemy.flashAt ? (now - enemy.flashAt) : 9999;
        if (rt < 190 && input.velocity > 1.15 && focus > 0.08) {
          focus = Math.min(1, focus + 0.14);
          cam.flash = Math.max(cam.flash, 0.25);
          cam.shake = Math.max(cam.shake, 10 * config.screenShake);
          burst(sx, sy, 'rgba(0,243,255,1)', 16, 'spark');
          showMessage(t('MSG_PARRY'), 'rgba(0,243,255,1)', t('MSG_RESET'));
          SFX.metal();
          if (navigator.vibrate) navigator.vibrate([20, 15, 20]);
          enemy.state = 'APPROACH';
          enemy.z = Math.max(enemy.z, 1150);
          enemy.t = 0;
          enemy.flashAt = 0;
          updateHUD();
          return true;
        }
        combo = 0; comboTimer = 0;
        cam.shake = Math.max(cam.shake, 9);
        burst(sx, sy, 'rgba(255,140,0,1)', 18, 'spark');
        showMessage(t('MSG_DEFLECT'), 'rgba(255,140,0,1)', t('MSG_WRONG'));
        SFX.metal();
        enemy.t += 0.06;
        updateHUD();
        if (navigator.vibrate) navigator.vibrate([20, 20, 20]);
        return true;
      }
    }

    function beatDeltaMs() {
      // distance to last quarter note (approx). returns large number if not available.
      if (!audio.lastBeatAt) return 9999;
      return Math.abs(performance.now() - audio.lastBeatAt);
    }

    function killEnemy(enemy, dir) {
      enemy.state = 'DONE';
      const p = enemyProjection(enemy);
      const now = performance.now();
      const rt = enemy.flashAt ? (now - enemy.flashAt) : 9999;
      let grade = 'KILL';
      let gradeColor = 'rgba(255,255,255,0.95)';
      let bonus = 0;

      if (rt < 260) { grade = 'PERFECT'; gradeColor = 'rgba(0,243,255,1)'; bonus = 2; focus = Math.min(1, focus + 0.20); health = Math.min(3, health + 1); }
      else if (rt < 460) { grade = 'GREAT'; gradeColor = 'rgba(166,255,0,1)'; bonus = 1; focus = Math.min(1, focus + 0.12); }
      else { focus = Math.min(1, focus + 0.06); }

      const odGain = (grade === 'PERFECT') ? 0.22 : (grade === 'GREAT' ? 0.14 : 0.10);
      overdrive = Math.min(1, overdrive + odGain);

      const mult = 1 + Math.floor(combo / 5) + (overdriveActive > 0 ? 1 : 0);

      // NEW: Rhythm Sync bonus (rhythm-game feel)
      let rhythmBonus = 0;
      if (config.rhythmSync) {
        const d = beatDeltaMs();
        // tighter window during overdrive for "skill" feel
        const win = (overdriveActive > 0) ? 110 : 140;
        if (d <= win) {
          rhythmBonus = 1;
          cam.flash = Math.max(cam.flash, 0.85);
          cam.lightning = Math.max(cam.lightning, 0.35);
          burst(p.sx, p.sy, 'rgba(255,255,255,0.9)', 10, 'spark');
          SFX.onBeat();
          showMessage('ON BEAT', 'rgba(255,238,0,1)', `+${rhythmBonus * mult}`);
        }
      }

      score += (1 + bonus + rhythmBonus) * mult;
      combo += 1; comboTimer = 3.0;
      intensity = Math.min(24, intensity + 0.4);
      killsTotal += 1;

      if (killsTotal > 0 && killsTotal % 12 === 0) {
        spawnBossNext = true;
        showMessage(t('MSG_BOSS'), 'rgba(255,0,85,1)', t('MSG_CHAIN'));
      }

      const heavy = (enemy.kind === ENEMY_KIND.BOSS);
      cam.shake = Math.max(cam.shake, (grade === 'PERFECT' ? 26 : 18) * config.screenShake + (heavy ? 12 : 0));
      cam.flash = Math.max(cam.flash, grade === 'PERFECT' ? 0.95 : 0.6);
      hitStop = heavy ? 0.10 : (grade === 'PERFECT' ? 0.07 : 0.045);
      cam.dashT = (grade === 'PERFECT' ? 0.22 : 0.14) + (heavy ? 0.08 : 0);
      cam.dashDX = (Math.random() * 2 - 1) * (grade === 'PERFECT' ? 36 : 22);
      cam.dashDY = (Math.random() * 2 - 1) * (grade === 'PERFECT' ? 26 : 16);

      bloodStreak(p.sx, p.sy, enemy.neon);
      if (heavy) {
        bloodStreak(p.sx, p.sy, 'rgba(255,255,255,0.9)');
        cam.lightning = Math.max(cam.lightning, 1.0);
      }
      SFX.shatter(); SFX.sheath();
      if (navigator.vibrate) navigator.vibrate(grade === 'PERFECT' ? [40, 25, 40] : 35);

      dead.push({
        kind: enemy.kind, weak: enemy.weak, neon: enemy.neon,
        x: enemy.x, y: enemy.y, z: enemy.z, dir, split: 0, life: 1.0, seed: enemy.seed,
      });

      if (enemy.kind === ENEMY_KIND.BOSS) {
        fatalityT = 1.1;
        document.body.classList.add('fatality-mode');
        showMessage(t('MSG_FATALITY'), 'rgba(255,0,85,1)', `+${(1 + bonus) * mult}`);
      } else {
        showMessage(grade, gradeColor, `+${(1 + bonus) * mult}`);
      }
      updateHUD();
      spawnCooldown = Math.max(0.06, spawnCooldown - 0.05);
    }

    function takeDamage() {
      combo = 0; comboTimer = 0; focus = Math.max(0, focus - 0.25);
      if (config.practice) {
        cam.redFlash = Math.max(cam.redFlash, 0.30);
        cam.shake = Math.max(cam.shake, 12 * config.screenShake);
        SFX.hit();
        showMessage(t('PRACTICE'), 'rgba(255,255,255,0.95)', 'NO DAMAGE');
        updateHUD();
        return;
      }

      // NEW: SECOND WIND
      if (health <= 1 && overdrive >= 1.0) {
        health = 1;
        overdrive = 0;
        overdriveActive = 0;
        cam.flash = 1.0;
        cam.shake = 30;
        SFX.thunder();
        // clear enemies close by
        enemies.forEach(e => {
          if (e.z < 1200) e.z += 800; // push back
        });
        showMessage(t('MSG_RESTORED'), 'rgba(0,255,255,1)', t('MSG_SECOND_WIND'));
        updateHUD();
        return;
      }

      health -= 1;
      cam.redFlash = Math.max(cam.redFlash, 0.85);
      cam.shake = Math.max(cam.shake, 16 * config.screenShake);
      SFX.hit();
      showMessage('WARNING', 'rgba(255,70,70,1)', 'TOO SLOW');
      updateHUD();
      if (navigator.vibrate) navigator.vibrate([60, 30, 60]);
      if (health <= 0) gameOver();
    }

    function gameOver() {
      state = STATE.OVER;
      hudTop.classList.add('hidden');
      bottomHints.classList.add('hidden');
      document.getElementById('game-over-screen').classList.remove('hidden');
      document.getElementById('final-score').innerText = String(score);
      bestScore = Math.max(bestScore, score);
      localStorage.setItem(LS_BEST, String(bestScore));
      document.getElementById('final-best').innerText = String(bestScore);
      document.getElementById('best').innerText = String(bestScore);
      showMessage(t('MSG_OVER'), 'rgba(255,255,255,0.95)', t('MSG_REBOOT'));
    }

    function update(dt) {
      if (state !== STATE.PLAY) {
        if (config.rain) updateRain(dt * 0.6);
        updateParticles(dt * 0.6);
        updateMessages(dt);
        return;
      }
      if (fatalityT > 0) { fatalityT -= dt; if (fatalityT <= 0) document.body.classList.remove('fatality-mode'); }

      if (overdriveActive > 0) {
        overdriveActive -= dt;
        overdrive = Math.max(0, overdriveActive / 5.5);
        cam.odTint = Math.min(1, cam.odTint + dt * 1.8);
      } else {
        cam.odTint = Math.max(0, cam.odTint - dt * 1.6);
        overdrive = Math.max(0, overdrive - dt * 0.005);
      }
      const timeScale = (overdriveActive > 0) ? 0.72 : 1.0;
      let simDt = dt;
      if (hitStop > 0) { hitStop -= dt; simDt = dt * 0.08; }

      if (input.active) {
        input.holdTime += dt;
        const still = input.velocity < 0.12;
        if (still && input.holdTime > 0.18 && focus > 0.08) input.focusMode = true;
        else if (!still) input.focusMode = false;
      } else {
        input.holdTime = 0; input.focusMode = false;
      }

      if (input.focusMode) {
        focusStateEl.innerText = 'FOCUS';
        focus = Math.max(0, focus - (overdriveActive > 0 ? 0.14 : 0.22) * dt);
      } else {
        focusStateEl.innerText = 'FREE';
        focus = Math.min(1, focus + (overdriveActive > 0 ? 0.18 : 0.10) * dt);
      }

      if (comboTimer > 0) {
        comboTimer -= dt;
        if (comboTimer <= 0) { combo = 0; updateHUD(); }
      }
      cam.zoomTarget = 1 + (overdriveActive > 0 ? 0.06 : 0);
      intensity = Math.min(25, intensity + dt * 0.20);
      const maxEnemies = Math.min(3, 1 + Math.floor(intensity / 7));
      // Spawn logic moved to scheduleBeat for Rhythm Sync
      spawnCooldown -= dt;
      // Fallback spawn if music is off
      if (!config.music && spawnCooldown <= 0 && enemies.length < maxEnemies) {
        if (spawnBossNext) { spawnEnemy(ENEMY_KIND.BOSS); spawnBossNext = false; }
        else spawnEnemy();
        spawnCooldown = Math.max(0.22, 1.05 - intensity * 0.03);
      }

      const enemyDt = dt * timeScale;
      const approach = 1050 + intensity * 55;
      const attackZ = 680;
      for (const e of enemies) {
        // Ghost flicker logic
        if (e.kind === ENEMY_KIND.GHOST) {
          e.flicker -= dt * 4;
          if (e.flicker <= 0) e.flicker = Math.random() * 0.5 + 0.2;
        }

        if (e.state === 'APPROACH') {
          e.z -= approach * simDt;
          if (e.z <= attackZ) {
            e.z = attackZ;
            e.state = 'TELEGRAPH';
            e.t = 0;
            e.flashAt = performance.now();
            SFX.flash();
            if (e.kind === ENEMY_KIND.BOSS) showMessage(t('MSG_BOSS'), 'rgba(255,0,85,1)', t('MSG_CHAIN'));
            else showMessage('!', e.neon, 'KILL TIMING');
          }
        } else if (e.state === 'TELEGRAPH') {
          e.t += enemyDt;
          cam.zoomTarget = Math.max(cam.zoomTarget, 1.10 + (e.kind === ENEMY_KIND.BOSS ? 0.06 : 0));
          if (e.t >= 0.18) {
            e.state = 'WINDOW'; e.t = 0;
            const baseReact = (e.kind === ENEMY_KIND.BOSS) ? 0.95 : 0.78;
            e.react = baseReact - Math.min(0.28, intensity * 0.01);
            if (overdriveActive > 0) e.react += 0.10;
          }
        } else if (e.state === 'WINDOW') {
          e.t += enemyDt;
          cam.zoomTarget = Math.max(cam.zoomTarget, 1.22 + (e.kind === ENEMY_KIND.BOSS ? 0.08 : 0));
          if (input.velocity > 0.9) trySlash(e);
          if (e.t >= e.react) { e.state = 'DONE'; takeDamage(); }
        }
      }
      enemies = enemies.filter(e => e.state !== 'DONE');

      for (let i = dead.length - 1; i >= 0; i--) {
        dead[i].split += (1200 / dead[i].z) * simDt * 90;
        dead[i].life -= simDt * (dead[i].kind === ENEMY_KIND.BOSS ? 0.55 : 0.9);
        dead[i].z += simDt * 220;
        if (dead[i].life <= 0) dead.splice(i, 1);
      }

      if (input.velocity > 1.35 && (config.freeMouse || input.active)) {
        if (Math.random() < 0.22) { const tip = swordTip(); burst(tip.x, tip.y, 'rgba(255,255,255,0.9)', 6, 'spark'); }
        if (Math.random() < 0.05) SFX.whoosh(Math.min(1.4, input.velocity));
      }

      cam.shake = Math.max(0, cam.shake - dt * 40);
      cam.flash = Math.max(0, cam.flash - dt * 1.9);
      cam.redFlash = Math.max(0, cam.redFlash - dt * 1.6);
      cam.lightning = Math.max(0, cam.lightning - dt * 0.7);
      cam.zoom += (cam.zoomTarget - cam.zoom) * 0.10;

      if (cam.dashT > 0) {
        cam.dashT -= dt;
        const t = Math.max(0, cam.dashT);
        cam.offsetX += cam.dashDX * dt * 10;
        cam.offsetY += cam.dashDY * dt * 10;
        cam.offsetX *= (0.86 + t * 0.2);
        cam.offsetY *= (0.86 + t * 0.2);
      } else { cam.offsetX *= 0.88; cam.offsetY *= 0.88; }

      if (config.rain && Math.random() < 0.0025 * (0.6 + intensity * 0.02)) { cam.lightning = 1.0; SFX.thunder(); }

      if (config.rain) updateRain(dt);
      updateParticles(dt);
      updateMessages(dt);
      scheduleBeat(dt);
      updateHUD();
    }

    function updateMessages(dt) {
      if (msgTimer > 0) { msgTimer -= dt; if (msgTimer <= 0) { msgWrap.style.opacity = '0'; msgWrap.style.transform = 'scale(0.92)'; } }
    }

    function updateRain(dt) {
      const windX = -45;
      for (const r of raindrops) {
        r.x += windX * (0.3 + r.z) * dt;
        r.y += r.sp * (0.45 + r.z) * dt;
        if (r.y > H + 40) { r.y = -40; r.x = Math.random() * W; r.z = Math.random(); r.len = 8 + Math.random() * 22; r.sp = 280 + Math.random() * 520; }
        if (r.x < -60) r.x = W + 60;
      }
      if (audio.rainGain) { const g = (config.rain ? 0.18 : 0.0); audio.rainGain.gain.value += (g - audio.rainGain.gain.value) * 0.02; }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt * (p.type === 'blood' ? 0.9 : 1.25);
        p.x += p.vx * dt * 60; p.y += p.vy * dt * 60;
        p.vy += (p.type === 'blood' ? 0.20 : 0.12) * dt * 60;
        p.vx *= 0.985; p.vy *= 0.985; p.rot += p.vr;
        if (p.life <= 0) particles.splice(i, 1);
      }
      if (particles.length > 980) particles.splice(0, particles.length - 980);
    }

    function draw() {
      ctx.setTransform(1, 0, 0, 1, 0, 0); fxCtx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, world.width, world.height);
      fxCtx.clearRect(0, 0, fx.width, fx.height);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0); fxCtx.setTransform(DPR, 0, 0, DPR, 0, 0);

      const shake = cam.shake * config.screenShake;
      const sx = (Math.random() - 0.5) * shake;
      const sy = (Math.random() - 0.5) * shake;

      ctx.save();
      ctx.translate(sx + cam.offsetX, sy + cam.offsetY);
      ctx.translate(W / 2, H / 2); ctx.scale(cam.zoom, cam.zoom); ctx.translate(-W / 2, -H / 2);

      drawBackdrop();
      drawGrid();
      enemies.sort((a, b) => b.z - a.z);
      for (const e of enemies) drawEnemy(e);
      for (const d of dead) drawDead(d);
      ctx.restore();

      fxCtx.save();
      fxCtx.translate(sx + cam.offsetX, sy + cam.offsetY);
      fxCtx.translate(W / 2, H / 2); fxCtx.scale(cam.zoom, cam.zoom); fxCtx.translate(-W / 2, -H / 2);

      if (config.rain) drawRain();
      drawParticles();
      drawSword();
      drawReticle();
      fxCtx.restore();

      if (cam.flash > 0) { fxCtx.save(); fxCtx.globalAlpha = Math.min(1, cam.flash); fxCtx.fillStyle = 'rgba(255,255,255,0.9)'; fxCtx.fillRect(0, 0, W, H); fxCtx.restore(); }
      if (cam.redFlash > 0) { fxCtx.save(); fxCtx.globalAlpha = Math.min(1, cam.redFlash); fxCtx.fillStyle = 'rgba(255,0,50,0.55)'; fxCtx.fillRect(0, 0, W, H); fxCtx.restore(); }
      if (cam.lightning > 0) { fxCtx.save(); fxCtx.globalAlpha = Math.min(1, cam.lightning); fxCtx.fillStyle = 'rgba(255,255,255,0.55)'; fxCtx.fillRect(0, 0, W, H); fxCtx.restore(); }
      if (cam.odTint > 0) { fxCtx.save(); fxCtx.globalAlpha = 0.16 * cam.odTint; fxCtx.fillStyle = 'rgba(255,0,85,1)'; fxCtx.fillRect(0, 0, W, H); fxCtx.globalAlpha = 0.22 * cam.odTint; fxCtx.fillStyle = 'rgba(0,0,0,1)'; fxCtx.fillRect(0, 0, W, H); fxCtx.restore(); }
    }

    function drawBackdrop() {
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, '#0a0a0a'); g.addColorStop(0.55, '#070707'); g.addColorStop(1, '#040404');
      ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);
      ctx.save(); ctx.globalAlpha = 0.30; ctx.fillStyle = '#0f0f0f';
      const baseY = H * 0.52;
      for (let i = 0; i < 38; i++) {
        const x = (i / 38) * W; const w = W / 38 + 2; const h = 40 + (Math.sin(i * 2.3) + 1) * 45 + (Math.random() * 25);
        ctx.fillRect(x, baseY - h, w, h);
      }
      ctx.globalAlpha = 0.18; ctx.fillStyle = '#151515';
      for (let i = 0; i < 24; i++) {
        const x = (i / 24) * W + 10; const w = W / 24; const h = 35 + (Math.cos(i * 1.7) + 1) * 55;
        ctx.fillRect(x, baseY - h - 25, w, h);
      }
      ctx.restore();
      const fog = ctx.createLinearGradient(0, H * 0.38, 0, H * 0.65);
      fog.addColorStop(0, 'rgba(255,255,255,0)'); fog.addColorStop(0.5, 'rgba(255,255,255,0.06)'); fog.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = fog; ctx.fillRect(0, 0, W, H);
    }

    function drawGrid() {
      const cy = H / 2;
      // AUDIO REACTIVE BRIGHTNESS
      const pulse = audio.beatPulse || 0;
      const baseAlpha = 0.05 + 0.15 * pulse;
      const glowColor = overdriveActive > 0 ? `rgba(255,0,85,${baseAlpha})` : `rgba(0,243,255,${baseAlpha})`;

      ctx.save();
      ctx.strokeStyle = glowColor;
      ctx.lineWidth = 2 + pulse * 2; // Lines get thicker on beat
      ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(W, cy); ctx.stroke();

      ctx.strokeStyle = glowColor;
      ctx.lineWidth = 1 + pulse;

      const time = performance.now() * 0.001;
      const speed = 1.4 + intensity * 0.06 + (overdriveActive > 0 ? 0.5 : 0);
      const offset = (time * 170 * speed) % 120;

      // Vertical Lines
      for (let i = -12; i <= 12; i++) {
        const x = W / 2 + i * 120;
        ctx.beginPath(); ctx.moveTo(W / 2, cy); ctx.lineTo(x * 2 - W / 2, H + 240); ctx.stroke();
      }

      // Horizontal Lines (Perspective)
      for (let z = 1; z < 26; z++) {
        const pz = z * 120 - offset; const depth = Math.max(30, pz);
        const scale = 780 / (depth); const y = cy + 260 * scale;
        if (y > H + 30) continue;

        // Make close lines pulsate more
        const distAlpha = Math.max(0, 0.4 - z * 0.015) * (1 + pulse);
        ctx.globalAlpha = Math.min(1, distAlpha);

        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
      }
      ctx.restore(); ctx.globalAlpha = 1;

      // Skyline Pulse
      if (pulse > 0.5) {
        ctx.save();
        ctx.globalAlpha = 0.03 * pulse;
        ctx.fillStyle = overdriveActive > 0 ? '#ff0055' : '#00f3ff';
        ctx.fillRect(0, 0, W, H);
        ctx.restore();
      }
    }

    function drawEnemy(e) {
      const p = enemyProjection(e);
      const fade = Math.max(0, Math.min(1, (2600 - e.z) / 1700));
      ctx.save(); ctx.translate(p.sx, p.sy);
      ctx.globalAlpha = 0.22 + 0.78 * fade;

      // GHOST logic: flicker opacity
      if (e.kind === ENEMY_KIND.GHOST) {
        if (e.state === 'APPROACH' && e.flicker < 0.2) ctx.globalAlpha = 0.05;
      }

      const jitter = (e.state === 'WINDOW') ? 2.2 : 1.0;
      ctx.translate((Math.random() - 0.5) * jitter, (Math.random() - 0.5) * jitter);
      ctx.shadowBlur = 48; ctx.shadowColor = e.neon;
      const size = (e.kind === ENEMY_KIND.BOSS) ? p.size * 1.22 : p.size;
      if (e.kind === ENEMY_KIND.DRONE) renderDrone(ctx, size, e);
      else renderOni(ctx, size, e);

      const alpha = (e.state === 'WINDOW') ? 1.0 : (e.state === 'TELEGRAPH' ? 0.72 : 0.35);
      ctx.globalAlpha = Math.min(1, ctx.globalAlpha + 0.15);
      drawWeakLine(ctx, size, e.weak, e.neon, alpha);

      if (e.kind === ENEMY_KIND.BOSS && e.seq) { ctx.globalAlpha = 1; drawBossSequence(ctx, size, e); }
      if (e.kind === ENEMY_KIND.SHIELD) {
        ctx.globalAlpha = 0.85; ctx.shadowBlur = 0; ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fillRect(-size * 0.22, size * 0.52, size * 0.44, 3);
        ctx.fillStyle = e.neon;
        ctx.fillRect(-size * 0.22, size * 0.52, size * 0.44 * (e.hp / 2), 3);
      }
      const fogAlpha = Math.max(0, Math.min(0.72, (e.z - 650) / 1900));
      if (fogAlpha > 0) {
        ctx.globalAlpha = fogAlpha; ctx.shadowBlur = 0; ctx.fillStyle = 'rgba(5,5,5,1)';
        ctx.beginPath(); ctx.arc(0, 0, size * 1.1, 0, Math.PI * 2); ctx.fill();
      }
      ctx.restore(); ctx.globalAlpha = 1;
    }

    function drawBossSequence(c, size, e) {
      const x0 = -size * 0.45; const y0 = -size * 0.95; const gap = size * 0.20;
      for (let i = 0; i < e.seq.length; i++) {
        const dir = e.seq[i]; const active = i === e.step; const done = i < e.step;
        c.save(); c.translate(x0 + i * gap, y0);
        c.globalAlpha = done ? 0.25 : (active ? 1.0 : 0.55);
        const col = done ? 'rgba(255,255,255,0.55)' : weakColor(dir);
        c.strokeStyle = col; c.lineWidth = Math.max(2, size * 0.02);
        c.shadowBlur = active ? 18 : 10; c.shadowColor = col;
        c.beginPath();
        if (dir === DIR.VERT) { c.moveTo(0, -size * 0.06); c.lineTo(0, size * 0.06); }
        else if (dir === DIR.HORZ) { c.moveTo(-size * 0.06, 0); c.lineTo(size * 0.06, 0); }
        else if (dir === DIR.DIAG1) { c.moveTo(-size * 0.055, -size * 0.055); c.lineTo(size * 0.055, size * 0.055); }
        else { c.moveTo(-size * 0.055, size * 0.055); c.lineTo(size * 0.055, -size * 0.055); }
        c.stroke(); c.restore();
      }
    }

    function drawDead(d) {
      const p = enemyProjection(d);
      ctx.save(); ctx.translate(p.sx, p.sy);
      ctx.globalAlpha = Math.max(0, d.life);
      const s = (d.kind === ENEMY_KIND.BOSS) ? p.size * 1.22 : p.size;
      const split = Math.min(s * 0.86, d.split);
      let dx = 0, dy = 0;
      if (d.dir === DIR.VERT) { dx = split; dy = 0; }
      if (d.dir === DIR.HORZ) { dx = 0; dy = split; }
      if (d.dir === DIR.DIAG1) { dx = split * 0.8; dy = split * 0.8; }
      if (d.dir === DIR.DIAG2) { dx = split * 0.8; dy = -split * 0.8; }
      ctx.shadowBlur = 18; ctx.shadowColor = 'rgba(255,255,255,0.15)';

      ctx.save(); ctx.translate(-dx, -dy); ctx.beginPath(); ctx.rect(-s * 1.2, -s * 1.2, s * 1.2, s * 2.4); ctx.clip(); renderDeadShape(ctx, s, d); ctx.restore();
      ctx.save(); ctx.translate(dx, dy); ctx.beginPath(); ctx.rect(0, -s * 1.2, s * 1.2, s * 2.4); ctx.clip(); renderDeadShape(ctx, s, d); ctx.restore();

      ctx.globalAlpha = Math.max(0, d.life) * 0.8; ctx.lineWidth = 3; ctx.strokeStyle = d.neon; ctx.shadowBlur = 22; ctx.shadowColor = d.neon;
      ctx.beginPath();
      if (d.dir === DIR.VERT) { ctx.moveTo(0, -s * 0.9); ctx.lineTo(0, s * 0.9); }
      else if (d.dir === DIR.HORZ) { ctx.moveTo(-s * 0.9, 0); ctx.lineTo(s * 0.9, 0); }
      else if (d.dir === DIR.DIAG1) { ctx.moveTo(-s * 0.8, -s * 0.8); ctx.lineTo(s * 0.8, s * 0.8); }
      else { ctx.moveTo(-s * 0.8, s * 0.8); ctx.lineTo(s * 0.8, -s * 0.8); }
      ctx.stroke();
      ctx.restore(); ctx.globalAlpha = 1;
    }

    function renderDeadShape(c, size, d) {
      c.shadowBlur = 0; c.fillStyle = '#0b0b0b'; c.strokeStyle = 'rgba(255,255,255,0.12)'; c.lineWidth = 2;
      c.beginPath(); c.moveTo(-size * 0.62, -size * 0.62); c.lineTo(size * 0.62, -size * 0.62);
      c.quadraticCurveTo(size * 0.78, 0, size * 0.45, size * 0.62); c.lineTo(0, size * 0.82);
      c.lineTo(-size * 0.45, size * 0.62); c.quadraticCurveTo(-size * 0.78, 0, -size * 0.62, -size * 0.62);
      c.closePath(); c.fill(); c.stroke();
    }

    function renderOni(c, size, e) {
      c.fillStyle = '#070707'; c.strokeStyle = 'rgba(255,255,255,0.14)'; c.lineWidth = 2;
      c.beginPath(); c.moveTo(-size * 0.62, -size * 0.58); c.lineTo(size * 0.62, -size * 0.58);
      c.quadraticCurveTo(size * 0.86, -size * 0.05, size * 0.52, size * 0.56); c.lineTo(0, size * 0.86);
      c.lineTo(-size * 0.52, size * 0.56); c.quadraticCurveTo(-size * 0.86, -size * 0.05, -size * 0.62, -size * 0.58);
      c.closePath(); c.fill(); c.stroke();
      c.globalAlpha = 0.8; c.fillStyle = '#0a0a0a';
      c.beginPath(); c.moveTo(-size * 0.55, -size * 0.15); c.lineTo(-size * 0.18, size * 0.44); c.lineTo(-size * 0.46, size * 0.50); c.closePath(); c.fill();
      c.beginPath(); c.moveTo(size * 0.55, -size * 0.15); c.lineTo(size * 0.18, size * 0.44); c.lineTo(size * 0.46, size * 0.50); c.closePath(); c.fill();
      c.globalAlpha = 1;
      c.shadowBlur = 18; c.shadowColor = e.neon; c.strokeStyle = e.neon; c.lineWidth = Math.max(2, size * 0.02);
      c.beginPath(); c.moveTo(-size * 0.42, -size * 0.58); c.lineTo(-size * 0.60, -size * 0.92); c.lineTo(-size * 0.36, -size * 0.72);
      c.moveTo(size * 0.42, -size * 0.58); c.lineTo(size * 0.60, -size * 0.92); c.lineTo(size * 0.36, -size * 0.72); c.stroke();
      c.shadowBlur = 12; c.shadowColor = 'rgba(255,255,255,0.85)'; c.fillStyle = 'rgba(255,255,255,0.72)';
      c.beginPath(); c.ellipse(-size * 0.22, -size * 0.06, size * 0.16, size * 0.08, 0, 0, Math.PI * 2);
      c.ellipse(size * 0.22, -size * 0.06, size * 0.16, size * 0.08, 0, 0, Math.PI * 2); c.fill();
      c.shadowBlur = 0; c.strokeStyle = 'rgba(255,255,255,0.16)'; c.lineWidth = 2;
      for (let i = -2; i <= 2; i++) { c.beginPath(); c.moveTo(-size * 0.22 + i * size * 0.09, size * 0.36); c.lineTo(-size * 0.18 + i * size * 0.09, size * 0.56); c.stroke(); }
    }

    function renderDrone(c, size, e) {
      c.shadowBlur = 26; c.shadowColor = e.neon; c.lineWidth = Math.max(2, size * 0.05); c.strokeStyle = e.neon; c.fillStyle = '#060606';
      c.beginPath(); c.arc(0, 0, size * 0.55, 0, Math.PI * 2); c.fill(); c.stroke();
      c.shadowBlur = 16; c.shadowColor = 'rgba(255,255,255,0.9)'; c.fillStyle = 'rgba(255,255,255,0.55)';
      c.beginPath(); c.arc(0, 0, size * 0.18, 0, Math.PI * 2); c.fill();
      c.shadowBlur = 0; c.strokeStyle = 'rgba(255,255,255,0.18)'; c.lineWidth = 2;
      for (let i = 0; i < 6; i++) { const a = (i / 6) * Math.PI * 2 + performance.now() * 0.0014; c.beginPath(); c.moveTo(Math.cos(a) * size * 0.2, Math.sin(a) * size * 0.2); c.lineTo(Math.cos(a) * size * 0.55, Math.sin(a) * size * 0.55); c.stroke(); }
    }

    function drawWeakLine(c, size, dir, color, alpha) {
      c.save(); c.globalAlpha = alpha; c.lineWidth = Math.max(3, size * 0.05); c.strokeStyle = color; c.shadowBlur = 26; c.shadowColor = color;
      c.beginPath();
      if (dir === DIR.VERT) { c.moveTo(0, -size * 0.8); c.lineTo(0, size * 0.8); }
      else if (dir === DIR.HORZ) { c.moveTo(-size * 0.8, 0); c.lineTo(size * 0.8, 0); }
      else if (dir === DIR.DIAG1) { c.moveTo(-size * 0.7, -size * 0.7); c.lineTo(size * 0.7, size * 0.7); }
      else { c.moveTo(-size * 0.7, size * 0.7); c.lineTo(size * 0.7, -size * 0.7); }
      c.stroke(); c.restore();
    }

    function drawRain() {
      fxCtx.save(); fxCtx.globalAlpha = 0.35; fxCtx.strokeStyle = 'rgba(180,180,180,0.55)'; fxCtx.lineWidth = 1;
      for (const r of raindrops) {
        const dx = -18 * (0.2 + r.z); const dy = r.len * (0.6 + r.z);
        fxCtx.beginPath(); fxCtx.moveTo(r.x, r.y); fxCtx.lineTo(r.x + dx, r.y + dy); fxCtx.stroke();
      }
      fxCtx.restore();
    }

    function drawParticles() {
      for (const p of particles) {
        fxCtx.save(); fxCtx.globalAlpha = Math.max(0, Math.min(1, p.life));
        fxCtx.translate(p.x, p.y); fxCtx.rotate(p.rot);
        fxCtx.shadowBlur = (p.type === 'blood' ? 18 : 12); fxCtx.shadowColor = p.color; fxCtx.fillStyle = p.color;
        if (p.type === 'shard') { fxCtx.fillRect(-p.size * 0.6, -p.size * 0.2, p.size * 1.2, p.size * 0.4); }
        else { fxCtx.beginPath(); fxCtx.arc(0, 0, p.size, 0, Math.PI * 2); fxCtx.fill(); }
        fxCtx.restore();
      }
      fxCtx.globalAlpha = 1;
    }

    function swordGrip() { return { x: W * 0.78, y: H * 0.86 }; }
    function swordTip() {
      const g = swordGrip();
      const tx = input.x || W * 0.65; const ty = input.y || H * 0.65;
      const x = Math.max(0, Math.min(W, tx)); const y = Math.max(0, Math.min(H, ty));
      return { x, y, gx: g.x, gy: g.y };
    }

    function bladePalette() {
      // NEW: Custom Blade Color
      if (overdriveActive > 0) return { glow: 'rgba(255,0,85,1)', mid: 'rgba(255,0,85,0.85)', outer: 'rgba(255,0,85,0.38)', core: 'rgba(255,255,255,0.98)' };

      let base = 'rgba(0,243,255,';
      if (config.bladeColor === 'pink') base = 'rgba(255,0,85,';
      if (config.bladeColor === 'lime') base = 'rgba(166,255,0,';
      if (config.bladeColor === 'purple') base = 'rgba(188,19,254,';

      return {
        glow: base + '1)',
        mid: base + '0.85)',
        outer: base + '0.38)',
        core: 'rgba(255,255,255,0.95)'
      };
    }

    function drawSword() {
      const g = swordGrip(); const tip = swordTip(); const ang = Math.atan2(tip.y - g.y, tip.x - g.x);
      fxCtx.save(); fxCtx.translate(g.x, g.y); fxCtx.rotate(ang);
      fxCtx.shadowBlur = 0; fxCtx.fillStyle = 'rgba(240,240,240,0.12)'; fxCtx.fillRect(-66, -12, 60, 24);
      fxCtx.fillStyle = 'rgba(255,255,255,0.18)'; for (let i = 0; i < 6; i++) fxCtx.fillRect(-64 + i * 10, -12, 2, 24);
      fxCtx.shadowBlur = 18; fxCtx.shadowColor = 'rgba(255,255,255,0.25)'; fxCtx.fillStyle = 'rgba(255,255,255,0.22)';
      fxCtx.beginPath(); fxCtx.roundRect(-8, -22, 18, 44, 7); fxCtx.fill();
      fxCtx.restore();

      const bladeLen = Math.hypot(tip.x - g.x, tip.y - g.y);
      const maxLen = Math.min(640, Math.max(260, bladeLen));
      const bx = g.x + Math.cos(ang) * maxLen; const by = g.y + Math.sin(ang) * maxLen;
      const vel = Math.min(2.8, input.velocity || 0);
      const pal = bladePalette();
      const odBoost = (overdriveActive > 0 ? 1.25 : 1.0);

      fxCtx.save(); fxCtx.lineCap = 'round'; fxCtx.lineJoin = 'round';
      const w = (30 + vel * 56) * config.trailScale * odBoost;
      fxCtx.shadowBlur = 58; fxCtx.shadowColor = pal.glow; fxCtx.strokeStyle = pal.outer; fxCtx.lineWidth = w;
      fxCtx.beginPath(); fxCtx.moveTo(g.x, g.y); fxCtx.lineTo(bx, by); fxCtx.stroke();
      fxCtx.shadowBlur = 20; fxCtx.strokeStyle = pal.mid; fxCtx.lineWidth = w * 0.44;
      fxCtx.beginPath(); fxCtx.moveTo(g.x, g.y); fxCtx.lineTo(bx, by); fxCtx.stroke();
      fxCtx.shadowBlur = 0; fxCtx.strokeStyle = pal.core; fxCtx.lineWidth = Math.max(2, w * 0.12);
      fxCtx.beginPath(); fxCtx.moveTo(g.x, g.y); fxCtx.lineTo(bx, by); fxCtx.stroke();
      fxCtx.shadowBlur = 20; fxCtx.shadowColor = 'rgba(255,255,255,0.9)'; fxCtx.fillStyle = 'rgba(255,255,255,0.9)';
      fxCtx.beginPath(); fxCtx.arc(bx, by, 4 + vel * 3, 0, Math.PI * 2); fxCtx.fill();
      fxCtx.restore();

      if (input.points.length > 2) {
        fxCtx.save(); fxCtx.lineCap = 'round'; fxCtx.lineJoin = 'round';
        for (let i = 0; i < input.points.length - 1; i++) {
          const p1 = input.points[i]; const p2 = input.points[i + 1];
          const age = (performance.now() - p1.t) / 235; if (age > 1) continue;
          const a = 1 - age; const ww = (16 + vel * 76) * config.trailScale * odBoost * a;
          fxCtx.shadowBlur = 56; fxCtx.shadowColor = pal.glow;
          fxCtx.strokeStyle = pal.outer.replace(/[\d.]+\)$/, (0.18 * a) + ')');
          fxCtx.lineWidth = ww; fxCtx.beginPath(); fxCtx.moveTo(p1.x, p1.y); fxCtx.lineTo(p2.x, p2.y); fxCtx.stroke();
          fxCtx.shadowBlur = 18; fxCtx.strokeStyle = pal.mid.replace(/[\d.]+\)$/, (0.62 * a) + ')');
          fxCtx.lineWidth = ww * 0.42; fxCtx.stroke();
          fxCtx.shadowBlur = 0; fxCtx.strokeStyle = `rgba(255,255,255,${0.90 * a})`;
          fxCtx.lineWidth = Math.max(2, ww * 0.11); fxCtx.stroke();
        }
        fxCtx.restore();
      }
    }

    function drawReticle() {
      if (state !== STATE.PLAY || !input.focusMode) return;
      fxCtx.save(); const x = W / 2; const y = H / 2;
      fxCtx.globalAlpha = 0.75; fxCtx.strokeStyle = 'rgba(255,255,255,0.65)'; fxCtx.lineWidth = 1;
      fxCtx.beginPath(); fxCtx.arc(x, y, 18, 0, Math.PI * 2); fxCtx.stroke();
      fxCtx.strokeStyle = (overdriveActive > 0) ? 'rgba(255,0,85,0.70)' : 'rgba(0,243,255,0.65)';
      fxCtx.beginPath(); fxCtx.arc(x, y, 32, 0, Math.PI * 2); fxCtx.stroke();
      fxCtx.restore();
    }

    function resize() {
      DPR = Math.min(2, window.devicePixelRatio || 1);
      W = window.innerWidth; H = window.innerHeight;
      world.width = Math.floor(W * DPR); world.height = Math.floor(H * DPR);
      world.style.width = W + 'px'; world.style.height = H + 'px';
      fx.width = Math.floor(W * DPR); fx.height = Math.floor(H * DPR);
      fx.style.width = W + 'px'; fx.style.height = H + 'px';
      initRain();
    }
    window.addEventListener('resize', resize); resize();

    function loop(t) {
      const dt = Math.min(0.04, (t - lastTime) / 1000 || 0);
      lastTime = t; update(dt); draw(); requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    document.getElementById('start-btn').addEventListener('click', () => {
      document.getElementById('start-screen').classList.add('hidden');
      document.body.classList.add('cinematic-mode');
      hudTop.classList.remove('hidden');
      bottomHints.classList.remove('hidden');
      document.getElementById('pause-screen').classList.add('hidden');
      document.getElementById('game-over-screen').classList.add('hidden');
      ensureAudio(); resetRun(); state = STATE.PLAY;
      showMessage(t('MSG_SCAN'), 'rgba(0,243,255,1)', t('MSG_LISTEN'));
    });

    document.getElementById('restart-btn').addEventListener('click', () => {
      document.getElementById('game-over-screen').classList.add('hidden');
      hudTop.classList.remove('hidden');
      bottomHints.classList.remove('hidden');
      ensureAudio(); resetRun(); state = STATE.PLAY;
      showMessage(t('MSG_REBOOT'), 'rgba(0,243,255,1)', '');
    });

    document.getElementById('copy-score-btn').addEventListener('click', async () => {
      const txt = `NEON BLOOD SCORE: ${score} (KILLS: ${killsTotal}, BEST: ${bestScore})`;
      try { await navigator.clipboard.writeText(txt); showMessage('COPIED', 'rgba(166,255,0,1)', txt); }
      catch { showMessage('COPY FAILED', 'rgba(255,200,80,1)', txt); }
    });

    document.getElementById('open-settings-btn').addEventListener('click', () => {
      document.getElementById('pause-screen').classList.remove('hidden');
      state = (state === STATE.MENU) ? STATE.MENU : STATE.PAUSE;
      updateText();
      showMessage(t('SETTINGS'), 'rgba(255,255,255,0.92)', '');
    });

    document.getElementById('resume-btn').addEventListener('click', () => {
      if (state === STATE.MENU) { document.getElementById('pause-screen').classList.add('hidden'); showMessage(t('MSG_READY'), 'rgba(255,255,255,0.92)', ''); }
      else resume();
    });

    const sens = document.getElementById('sens'); const trail = document.getElementById('trail'); const vol = document.getElementById('vol');
    const sensVal = document.getElementById('sens-val'); const trailVal = document.getElementById('trail-val'); const volVal = document.getElementById('vol-val');
    function bindRange(el, onChange) { el.addEventListener('input', () => onChange(Number(el.value))); }
    bindRange(sens, (v) => { config.sensitivity = v; sensVal.innerText = v.toFixed(2); });
    bindRange(trail, (v) => { config.trailScale = v; trailVal.innerText = v.toFixed(2); });
    bindRange(vol, (v) => { setVolume(v); volVal.innerText = v.toFixed(2); });

    const btnShake = document.getElementById('toggle-shake');
    const btnRain = document.getElementById('toggle-rain');
    const btnFree = document.getElementById('toggle-free');
    const btnPractice = document.getElementById('toggle-practice');
    const btnLang = document.getElementById('toggle-lang');

    btnShake.addEventListener('click', () => { config.screenShake = (config.screenShake > 0) ? 0 : 1; updateText(); if (config.screenShake === 0) cam.shake = 0; });
    btnRain.addEventListener('click', () => { config.rain = !config.rain; updateText(); if (audio.rainGain) audio.rainGain.gain.value = config.rain ? 0.18 : 0.0; });
    btnFree.addEventListener('click', () => { config.freeMouse = !config.freeMouse; updateText(); });
    btnPractice.addEventListener('click', () => { config.practice = !config.practice; updateText(); showMessage(config.practice ? 'PRACTICE ON' : 'PRACTICE OFF', 'rgba(255,255,255,0.92)', config.practice ? 'NO DAMAGE' : 'LIVE MODE'); updateHUD(); });
    btnLang.addEventListener('click', () => { config.lang = (config.lang === 'EN') ? 'KO' : 'EN'; updateText(); });

    function setBladeColor(c) {
      config.bladeColor = c;
      document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
      event.target.classList.add('selected');
    }

    sensVal.innerText = config.sensitivity.toFixed(2);
    trailVal.innerText = config.trailScale.toFixed(2);
    volVal.innerText = config.volume.toFixed(2);
    updateText();
    showMessage(t('MSG_READY'), 'rgba(255,255,255,0.92)', t('INITIATE'));
  </script>
  <script>
    // --- Premium Shop & Capture Integration ---
    window.buyPremiumItem = function (item, price) {
      if (window.parent) window.parent.postMessage({ type: 'PURCHASE_REQUEST', item: item, price: price, gameId: 'neon-blood' }, '*');
    };

    window.addEventListener('message', e => {
      if (e.data.type === 'CAPTURE_REQUEST') {
        const canvas = document.getElementById('world-layer');
        if (canvas) window.parent.postMessage({ type: 'CAPTURE_SUCCESS', imageData: canvas.toDataURL() }, '*');
      } else if (e.data.type === 'PURCHASE_SUCCESS') {
        alert('UNLOCKED: ' + e.data.item);
        // Unlock logic here
        window.unlockedBlades = true;
      }
    });

    window.addEventListener('keydown', e => {
      if (e.key === 'F2') {
        e.preventDefault();
        if (window.parent) window.parent.postMessage({ type: 'F2_PRESSED' }, '*');
      }
    });
  </script>
</body>

</html>